/** generated by @odit/swagger-axios-codegen */
// @ts-nocheck
/* eslint-disable */

/** generated by @odit/swagger-axios-codegen */
/* eslint-disable */
// @ts-nocheck
import type { AxiosInstance, AxiosRequestConfig } from "axios";

export interface IRequestOptions extends AxiosRequestConfig {
  /** only in axios interceptor config*/
  loading: boolean;
}

export interface IRequestConfig {
  method?: any;
  headers?: any;
  url?: any;
  data?: any;
  params?: any;
}

// Add options interface
export interface ServiceOptions {
  axios?: AxiosInstance;
  /** only in axios interceptor config*/
  loading: boolean;
}

// Add default options
export const serviceOptions: ServiceOptions = {};

// Instance selector
export function axios(
  configs: IRequestConfig,
  resolve: (p: any) => void,
  reject: (p: any) => void
): Promise<any> {
  if (serviceOptions.axios) {
    return serviceOptions.axios
      .request(configs)
      .then((res) => {
        resolve(res.data);
      })
      .catch((err) => {
        reject(err);
      });
  } else {
    throw new Error("please inject yourself instance like axios  ");
  }
}

export function getConfigs(
  method: string,
  contentType: string,
  url: string,
  options: any
): IRequestConfig {
  const configs: IRequestConfig = {
    loading: serviceOptions.loading,
    ...options,
    method,
    url,
  };
  configs.headers = {
    ...options.headers,
    "Content-Type": contentType,
  };
  return configs;
}

export const basePath = "";

export interface IList<T> extends Array<T> {}
export interface List<T> extends Array<T> {}
export interface IDictionary<TValue> {
  [key: string]: TValue;
}
export interface Dictionary<TValue> extends IDictionary<TValue> {}

export interface IListResult<T> {
  items?: T[];
}

export class ListResultDto<T> implements IListResult<T> {
  items?: T[];
}

export interface IPagedResult<T> extends IListResult<T> {
  totalCount?: number;
  items?: T[];
}

export class PagedResultDto<T = any> implements IPagedResult<T> {
  totalCount?: number;
  items?: T[];
}

// customer definition
// empty

export class CheckAccountService {
  /**
   * Retrieve check accounts
   */
  static getCheckAccounts(options: IRequestOptions = {}): Promise<any> {
    return new Promise((resolve, reject) => {
      let url = basePath + "/CheckAccount";

      const configs: IRequestConfig = getConfigs(
        "get",
        "application/json",
        url,
        options
      );

      axios(configs, resolve, reject);
    });
  }
  /**
   * Create a new check account
   */
  static createCheckAccount(
    params: {
      /** requestBody */
      body?: Model_CheckAccount;
    } = {} as any,
    options: IRequestOptions = {}
  ): Promise<any> {
    return new Promise((resolve, reject) => {
      let url = basePath + "/CheckAccount";

      const configs: IRequestConfig = getConfigs(
        "post",
        "application/json",
        url,
        options
      );

      let data = params.body;

      configs.data = data;

      axios(configs, resolve, reject);
    });
  }
  /**
   * Find check account by ID
   */
  static getCheckAccountById(
    params: {
      /** ID of check account */
      checkAccountId: number;
    } = {} as any,
    options: IRequestOptions = {}
  ): Promise<any> {
    return new Promise((resolve, reject) => {
      let url = basePath + "/CheckAccount/{checkAccountId}";
      url = url.replace("{checkAccountId}", params["checkAccountId"] + "");

      const configs: IRequestConfig = getConfigs(
        "get",
        "application/json",
        url,
        options
      );

      axios(configs, resolve, reject);
    });
  }
  /**
   * Update an existing check account
   */
  static updateCheckAccount(
    params: {
      /** ID of check account to update */
      checkAccountId: number;
      /** requestBody */
      body?: Model_CheckAccountUpdate;
    } = {} as any,
    options: IRequestOptions = {}
  ): Promise<Model_CheckAccountResponse> {
    return new Promise((resolve, reject) => {
      let url = basePath + "/CheckAccount/{checkAccountId}";
      url = url.replace("{checkAccountId}", params["checkAccountId"] + "");

      const configs: IRequestConfig = getConfigs(
        "put",
        "application/json",
        url,
        options
      );

      let data = params.body;

      configs.data = data;

      axios(configs, resolve, reject);
    });
  }
  /**
   * Deletes a check account
   */
  static deleteCheckAccount(
    params: {
      /** Id of check account to delete */
      checkAccountId: number;
    } = {} as any,
    options: IRequestOptions = {}
  ): Promise<any> {
    return new Promise((resolve, reject) => {
      let url = basePath + "/CheckAccount/{checkAccountId}";
      url = url.replace("{checkAccountId}", params["checkAccountId"] + "");

      const configs: IRequestConfig = getConfigs(
        "delete",
        "application/json",
        url,
        options
      );

      let data = null;

      configs.data = data;

      axios(configs, resolve, reject);
    });
  }
  /**
   * Get the balance at a given date
   */
  static getBalanceAtDate(
    params: {
      /** ID of check account */
      checkAccountId: number;
      /** Only consider transactions up to this date at 23:59:59 */
      date: string;
    } = {} as any,
    options: IRequestOptions = {}
  ): Promise<any> {
    return new Promise((resolve, reject) => {
      let url = basePath + "/CheckAccount/{checkAccountId}/getBalanceAtDate";
      url = url.replace("{checkAccountId}", params["checkAccountId"] + "");

      const configs: IRequestConfig = getConfigs(
        "get",
        "application/json",
        url,
        options
      );
      configs.params = { date: params["date"] };

      axios(configs, resolve, reject);
    });
  }
}

export class CheckAccountTransactionService {
  /**
   * Retrieve transactions
   */
  static getTransactions(
    params: {
      /** Only retrieve booked transactions */
      isBooked?: boolean;
      /** Only retrieve transactions with this payment purpose */
      paymtPurpose?: string;
      /** Only retrieve transactions from this date on */
      startDate?: string;
      /** Only retrieve transactions up to this date */
      endDate?: string;
      /** Only retrieve transactions with this payee / payer */
      payeePayerName?: string;
      /** Only retrieve credit transactions */
      onlyCredit?: boolean;
      /** Only retrieve debit transactions */
      onlyDebit?: boolean;
    } = {} as any,
    options: IRequestOptions = {}
  ): Promise<any> {
    return new Promise((resolve, reject) => {
      let url = basePath + "/CheckAccountTransaction";

      const configs: IRequestConfig = getConfigs(
        "get",
        "application/json",
        url,
        options
      );
      configs.params = {
        isBooked: params["isBooked"],
        paymtPurpose: params["paymtPurpose"],
        startDate: params["startDate"],
        endDate: params["endDate"],
        payeePayerName: params["payeePayerName"],
        onlyCredit: params["onlyCredit"],
        onlyDebit: params["onlyDebit"],
      };

      axios(configs, resolve, reject);
    });
  }
  /**
   * Create a new transaction
   */
  static createTransaction(
    params: {
      /** requestBody */
      body?: Model_CheckAccountTransaction;
    } = {} as any,
    options: IRequestOptions = {}
  ): Promise<Model_CheckAccountTransactionResponse> {
    return new Promise((resolve, reject) => {
      let url = basePath + "/CheckAccountTransaction";

      const configs: IRequestConfig = getConfigs(
        "post",
        "application/json",
        url,
        options
      );

      let data = params.body;

      configs.data = data;

      axios(configs, resolve, reject);
    });
  }
  /**
   * Find check account transaction by ID
   */
  static getCheckAccountTransactionById(
    params: {
      /** ID of check account transaction */
      checkAccountTransactionId: number;
    } = {} as any,
    options: IRequestOptions = {}
  ): Promise<any> {
    return new Promise((resolve, reject) => {
      let url =
        basePath + "/CheckAccountTransaction/{checkAccountTransactionId}";
      url = url.replace(
        "{checkAccountTransactionId}",
        params["checkAccountTransactionId"] + ""
      );

      const configs: IRequestConfig = getConfigs(
        "get",
        "application/json",
        url,
        options
      );

      axios(configs, resolve, reject);
    });
  }
  /**
   * Update an existing check account transaction
   */
  static updateCheckAccountTransaction(
    params: {
      /** ID of check account to update transaction */
      checkAccountTransactionId: number;
      /** requestBody */
      body?: Model_CheckAccountTransactionUpdate;
    } = {} as any,
    options: IRequestOptions = {}
  ): Promise<Model_CheckAccountTransactionResponse> {
    return new Promise((resolve, reject) => {
      let url =
        basePath + "/CheckAccountTransaction/{checkAccountTransactionId}";
      url = url.replace(
        "{checkAccountTransactionId}",
        params["checkAccountTransactionId"] + ""
      );

      const configs: IRequestConfig = getConfigs(
        "put",
        "application/json",
        url,
        options
      );

      let data = params.body;

      configs.data = data;

      axios(configs, resolve, reject);
    });
  }
  /**
   * Deletes a check account transaction
   */
  static deleteCheckAccountTransaction(
    params: {
      /** Id of check account transaction to delete */
      checkAccountTransactionId: number;
    } = {} as any,
    options: IRequestOptions = {}
  ): Promise<any> {
    return new Promise((resolve, reject) => {
      let url =
        basePath + "/CheckAccountTransaction/{checkAccountTransactionId}";
      url = url.replace(
        "{checkAccountTransactionId}",
        params["checkAccountTransactionId"] + ""
      );

      const configs: IRequestConfig = getConfigs(
        "delete",
        "application/json",
        url,
        options
      );

      let data = null;

      configs.data = data;

      axios(configs, resolve, reject);
    });
  }
}

export class ContactService {
  /**
   * Get next free customer number
   */
  static getNextCustomerNumber(
    options: IRequestOptions = {}
  ): Promise<ObjectsWrapper<string>> {
    return new Promise((resolve, reject) => {
      let url = basePath + "/Contact/Factory/getNextCustomerNumber";

      const configs: IRequestConfig = getConfigs(
        "get",
        "application/json",
        url,
        options
      );

      axios(configs, resolve, reject);
    });
  }
  /**
   * Find contacts by custom field value
   */
  static findContactsByCustomFieldValue(
    params: {
      /** The value to be checked. */
      value: string;
      /** The ContactCustomFieldSetting name, if no ContactCustomFieldSetting is provided. */
      customFieldName: string;
    } = {} as any,
    options: IRequestOptions = {}
  ): Promise<any> {
    return new Promise((resolve, reject) => {
      let url = basePath + "/Contact/Factory/findContactsByCustomFieldValue";

      const configs: IRequestConfig = getConfigs(
        "get",
        "application/json",
        url,
        options
      );
      configs.params = {
        value: params["value"],
        customFieldName: params["customFieldName"],
      };

      axios(configs, resolve, reject);
    });
  }
  /**
   * Check if a customer number is available
   */
  static contactCustomerNumberAvailabilityCheck(
    params: {
      /** The customer number to be checked. */
      customerNumber?: string;
    } = {} as any,
    options: IRequestOptions = {}
  ): Promise<any> {
    return new Promise((resolve, reject) => {
      let url = basePath + "/Contact/Mapper/checkCustomerNumberAvailability";

      const configs: IRequestConfig = getConfigs(
        "get",
        "application/json",
        url,
        options
      );
      configs.params = { customerNumber: params["customerNumber"] };

      axios(configs, resolve, reject);
    });
  }
  /**
   * Retrieve contacts
   */
  static getContacts(
    params: {
      /** Defines if both organizations <b>and</b> persons should be returned.<br>
     '0' -> only organizations, '1' -> organizations and persons */
      depth?: string;
      /** Retrieve all contacts with this customer number */
      customerNumber?: string;
    } = {} as any,
    options: IRequestOptions = {}
  ): Promise<ObjectsWrapper<Array<Model_ContactResponse>>> {
    return new Promise((resolve, reject) => {
      let url = basePath + "/Contact";

      const configs: IRequestConfig = getConfigs(
        "get",
        "application/json",
        url,
        options
      );
      configs.params = {
        depth: params["depth"],
        customerNumber: params["customerNumber"],
      };

      axios(configs, resolve, reject);
    });
  }
  /**
   * Create a new contact
   */
  static createContact(
    params: {
      /** requestBody */
      body?: Model_Contact;
    } = {} as any,
    options: IRequestOptions = {}
  ): Promise<ObjectsWrapper<Model_ContactResponse>> {
    return new Promise((resolve, reject) => {
      let url = basePath + "/Contact";

      const configs: IRequestConfig = getConfigs(
        "post",
        "application/json",
        url,
        options
      );

      let data = params.body;

      configs.data = data;

      axios(configs, resolve, reject);
    });
  }
  /**
   * Find contact by ID
   * NOTE: API returns an array, instead of just single object
   */
  static getContactById(
    params: {
      /** ID of contact to return */
      contactId: number;
    } = {} as any,
    options: IRequestOptions = {}
  ): Promise<ObjectsWrapper<Array<Model_ContactResponse>>> {
    return new Promise((resolve, reject) => {
      let url = basePath + "/Contact/{contactId}";
      url = url.replace("{contactId}", params["contactId"] + "");

      const configs: IRequestConfig = getConfigs(
        "get",
        "application/json",
        url,
        options
      );

      axios(configs, resolve, reject);
    });
  }
  /**
   * Update a existing contact
   */
  static updateContact(
    params: {
      /** ID of contact to update */
      contactId: number;
      /** requestBody */
      body?: Model_ContactUpdate;
    } = {} as any,
    options: IRequestOptions = {}
  ): Promise<ObjectsWrapper<Model_ContactResponse>> {
    return new Promise((resolve, reject) => {
      let url = basePath + "/Contact/{contactId}";
      url = url.replace("{contactId}", params["contactId"] + "");

      const configs: IRequestConfig = getConfigs(
        "put",
        "application/json",
        url,
        options
      );

      let data = params.body;

      configs.data = data;

      axios(configs, resolve, reject);
    });
  }
  /**
   * Deletes a contact
   */
  static deleteContact(
    params: {
      /** Id of contact resource to delete */
      contactId: number;
    } = {} as any,
    options: IRequestOptions = {}
  ): Promise<ObjectsWrapper<any>> {
    return new Promise((resolve, reject) => {
      let url = basePath + "/Contact/{contactId}";
      url = url.replace("{contactId}", params["contactId"] + "");

      const configs: IRequestConfig = getConfigs(
        "delete",
        "application/json",
        url,
        options
      );

      let data = null;

      configs.data = data;

      axios(configs, resolve, reject);
    });
  }
  /**
   * Get number of all items
   */
  static getContactTabsItemCountById(
    params: {
      /** ID of contact to return */
      contactId: number;
    } = {} as any,
    options: IRequestOptions = {}
  ): Promise<any> {
    return new Promise((resolve, reject) => {
      let url = basePath + "/Contact/{contactId}/getTabsItemCount";
      url = url.replace("{contactId}", params["contactId"] + "");

      const configs: IRequestConfig = getConfigs(
        "get",
        "application/json",
        url,
        options
      );

      axios(configs, resolve, reject);
    });
  }
}

export class ContactAddressService {
  /**
   * Create a new contact address
   */
  static createContactAddress(
    params: {
      /** requestBody */
      body?: Model_ContactAddress;
    } = {} as any,
    options: IRequestOptions = {}
  ): Promise<ObjectsWrapper<Model_ContactAddressResponse>> {
    return new Promise((resolve, reject) => {
      let url = basePath + "/ContactAddress";

      const configs: IRequestConfig = getConfigs(
        "post",
        "application/json",
        url,
        options
      );

      let data = params.body;

      configs.data = data;

      axios(configs, resolve, reject);
    });
  }
  /**
   * Retrieve contact addresses
   */
  static getContactAddresses(options: IRequestOptions = {}): Promise<any> {
    return new Promise((resolve, reject) => {
      let url = basePath + "/ContactAddress";

      const configs: IRequestConfig = getConfigs(
        "get",
        "application/json",
        url,
        options
      );

      axios(configs, resolve, reject);
    });
  }
  /**
   * Find contact address by ID
   */
  static getContactAddressById(
    params: {
      /** ID of contact address to return */
      contactAddressId: number;
    } = {} as any,
    options: IRequestOptions = {}
  ): Promise<ObjectsWrapper<Array<Model_ContactAddressResponse>>> {
    return new Promise((resolve, reject) => {
      let url = basePath + "/ContactAddress/{contactAddressId}";
      url = url.replace("{contactAddressId}", params["contactAddressId"] + "");

      const configs: IRequestConfig = getConfigs(
        "get",
        "application/json",
        url,
        options
      );

      axios(configs, resolve, reject);
    });
  }
  /**
   * update a existing contact address
   */
  static updateContactAddress(
    params: {
      /** ID of contact address to return */
      contactAddressId: number;
      /** requestBody */
      body?: Model_ContactAddressUpdate;
    } = {} as any,
    options: IRequestOptions = {}
  ): Promise<ObjectsWrapper<Model_ContactAddressResponse>> {
    return new Promise((resolve, reject) => {
      let url = basePath + "/ContactAddress/{contactAddressId}";
      url = url.replace("{contactAddressId}", params["contactAddressId"] + "");

      const configs: IRequestConfig = getConfigs(
        "put",
        "application/json",
        url,
        options
      );

      let data = params.body;

      configs.data = data;

      axios(configs, resolve, reject);
    });
  }
  /**
   * Deletes a contact address
   */
  static deleteContactAddress(
    params: {
      /** Id of contact address resource to delete */
      contactAddressId: number;
    } = {} as any,
    options: IRequestOptions = {}
  ): Promise<any> {
    return new Promise((resolve, reject) => {
      let url = basePath + "/ContactAddress/{contactAddressId}";
      url = url.replace("{contactAddressId}", params["contactAddressId"] + "");

      const configs: IRequestConfig = getConfigs(
        "delete",
        "application/json",
        url,
        options
      );

      let data = null;

      configs.data = data;

      axios(configs, resolve, reject);
    });
  }
}

export class CommunicationWayService {
  /**
   * Retrieve communication ways
   */
  static getCommunicationWays(
    params: {
      /** Type of the communication ways you want to get. */
      type?: string;
      /** Define if you only want the main communication way. */
      main?: string;
    } = {} as any,
    options: IRequestOptions = {}
  ): Promise<any> {
    return new Promise((resolve, reject) => {
      let url = basePath + "/CommunicationWay";

      const configs: IRequestConfig = getConfigs(
        "get",
        "application/json",
        url,
        options
      );
      configs.params = { type: params["type"], main: params["main"] };

      axios(configs, resolve, reject);
    });
  }
  /**
   * Create a new contact communication way
   */
  static createCommunicationWay(
    params: {
      /** requestBody */
      body?: Model_CommunicationWay;
    } = {} as any,
    options: IRequestOptions = {}
  ): Promise<ObjectsWrapper<Model_CommunicationWayResponse>> {
    return new Promise((resolve, reject) => {
      let url = basePath + "/CommunicationWay";

      const configs: IRequestConfig = getConfigs(
        "post",
        "application/json",
        url,
        options
      );

      let data = params.body;

      configs.data = data;

      axios(configs, resolve, reject);
    });
  }
  /**
   * Find communication way by ID
   * NOTE: API returns an array, instead of just single object
   */
  static getCommunicationWayById(
    params: {
      /** ID of communication way to return */
      communicationWayId: number;
    } = {} as any,
    options: IRequestOptions = {}
  ): Promise<ObjectsWrapper<Array<Model_CommunicationWayResponse>>> {
    return new Promise((resolve, reject) => {
      let url = basePath + "/CommunicationWay/{communicationWayId}";
      url = url.replace(
        "{communicationWayId}",
        params["communicationWayId"] + ""
      );

      const configs: IRequestConfig = getConfigs(
        "get",
        "application/json",
        url,
        options
      );

      axios(configs, resolve, reject);
    });
  }
  /**
   * Deletes a communication way
   */
  static deleteCommunicationWay(
    params: {
      /** Id of communication way resource to delete */
      communicationWayId: number;
    } = {} as any,
    options: IRequestOptions = {}
  ): Promise<any> {
    return new Promise((resolve, reject) => {
      let url = basePath + "/CommunicationWay/{communicationWayId}";
      url = url.replace(
        "{communicationWayId}",
        params["communicationWayId"] + ""
      );

      const configs: IRequestConfig = getConfigs(
        "delete",
        "application/json",
        url,
        options
      );

      let data = null;

      configs.data = data;

      axios(configs, resolve, reject);
    });
  }
  /**
   * Update a existing communication way
   */
  static updateCommunicationWay(
    params: {
      /** ID of CommunicationWay to update */
      communicationWayId: number;
      /** requestBody */
      body?: Model_CommunicationWayUpdate;
    } = {} as any,
    options: IRequestOptions = {}
  ): Promise<ObjectsWrapper<Model_CommunicationWayResponse>> {
    return new Promise((resolve, reject) => {
      let url = basePath + "/CommunicationWay/{communicationWayId}";
      url = url.replace(
        "{communicationWayId}",
        params["communicationWayId"] + ""
      );

      const configs: IRequestConfig = getConfigs(
        "put",
        "application/json",
        url,
        options
      );

      let data = params.body;

      configs.data = data;

      axios(configs, resolve, reject);
    });
  }
  /**
   * Retrieve communication way keys
   */
  static getCommunicationWayKeys(
    options: IRequestOptions = {}
  ): Promise<any | null> {
    return new Promise((resolve, reject) => {
      let url = basePath + "/CommunicationWayKey";

      const configs: IRequestConfig = getConfigs(
        "get",
        "application/json",
        url,
        options
      );

      axios(configs, resolve, reject);
    });
  }
}

export class AccountingContactService {
  /**
   * Create a new accounting contact
   */
  static createAccountingContact(
    params: {
      /** requestBody */
      body?: Model_AccountingContact;
    } = {} as any,
    options: IRequestOptions = {}
  ): Promise<Model_AccountingContactResponse> {
    return new Promise((resolve, reject) => {
      let url = basePath + "/AccountingContact";

      const configs: IRequestConfig = getConfigs(
        "post",
        "application/json",
        url,
        options
      );

      let data = params.body;

      configs.data = data;

      axios(configs, resolve, reject);
    });
  }
  /**
   * Find accounting contact by ID
   */
  static getAccountingContactById(
    params: {
      /** ID of accounting contact to return */
      accountingContactId: number;
    } = {} as any,
    options: IRequestOptions = {}
  ): Promise<any> {
    return new Promise((resolve, reject) => {
      let url = basePath + "/AccountingContact/{accountingContactId}";
      url = url.replace(
        "{accountingContactId}",
        params["accountingContactId"] + ""
      );

      const configs: IRequestConfig = getConfigs(
        "get",
        "application/json",
        url,
        options
      );

      axios(configs, resolve, reject);
    });
  }
  /**
   * Update an existing accounting contact
   */
  static updateAccountingContact(
    params: {
      /** ID of accounting contact to update */
      accountingContactId: number;
      /** requestBody */
      body?: Model_AccountingContactUpdate;
    } = {} as any,
    options: IRequestOptions = {}
  ): Promise<Model_AccountingContactResponse> {
    return new Promise((resolve, reject) => {
      let url = basePath + "/AccountingContact/{accountingContactId}";
      url = url.replace(
        "{accountingContactId}",
        params["accountingContactId"] + ""
      );

      const configs: IRequestConfig = getConfigs(
        "put",
        "application/json",
        url,
        options
      );

      let data = params.body;

      configs.data = data;

      axios(configs, resolve, reject);
    });
  }
  /**
   * Deletes an accounting contact
   */
  static deleteAccountingContact(
    params: {
      /** Id of accounting contact resource to delete */
      accountingContactId: number;
    } = {} as any,
    options: IRequestOptions = {}
  ): Promise<any> {
    return new Promise((resolve, reject) => {
      let url = basePath + "/AccountingContact/{accountingContactId}";
      url = url.replace(
        "{accountingContactId}",
        params["accountingContactId"] + ""
      );

      const configs: IRequestConfig = getConfigs(
        "delete",
        "application/json",
        url,
        options
      );

      let data = null;

      configs.data = data;

      axios(configs, resolve, reject);
    });
  }
}

export class ContactFieldService {
  /**
   * Retrieve Placeholders
   */
  static getPlaceholder(
    params: {
      /** Model name */
      objectName: string;
      /** Sub model name, required if you have "Email" at objectName */
      subObjectName?: string;
    } = {} as any,
    options: IRequestOptions = {}
  ): Promise<any> {
    return new Promise((resolve, reject) => {
      let url = basePath + "/Textparser/fetchDictionaryEntriesByType";

      const configs: IRequestConfig = getConfigs(
        "get",
        "application/json",
        url,
        options
      );
      configs.params = {
        objectName: params["objectName"],
        subObjectName: params["subObjectName"],
      };

      axios(configs, resolve, reject);
    });
  }
  /**
   * Retrieve contact fields
   */
  static getContactFields(options: IRequestOptions = {}): Promise<any | null> {
    return new Promise((resolve, reject) => {
      let url = basePath + "/ContactCustomField";

      const configs: IRequestConfig = getConfigs(
        "get",
        "application/json",
        url,
        options
      );

      axios(configs, resolve, reject);
    });
  }
  /**
   * Create contact field
   */
  static createContactField(
    params: {
      /** requestBody */
      body?: Model_ContactCustomField;
    } = {} as any,
    options: IRequestOptions = {}
  ): Promise<Model_ContactCustomFieldResponse> {
    return new Promise((resolve, reject) => {
      let url = basePath + "/ContactCustomField";

      const configs: IRequestConfig = getConfigs(
        "post",
        "application/json",
        url,
        options
      );

      let data = params.body;

      configs.data = data;

      axios(configs, resolve, reject);
    });
  }
  /**
   * Retrieve contact fields
   */
  static getContactFieldsById(
    params: {
      /** id of the contact field */
      contactCustomFieldId: number;
    } = {} as any,
    options: IRequestOptions = {}
  ): Promise<any | null> {
    return new Promise((resolve, reject) => {
      let url = basePath + "/ContactCustomField/{contactCustomFieldId}";
      url = url.replace(
        "{contactCustomFieldId}",
        params["contactCustomFieldId"] + ""
      );

      const configs: IRequestConfig = getConfigs(
        "get",
        "application/json",
        url,
        options
      );

      axios(configs, resolve, reject);
    });
  }
  /**
   * Update a contact field
   */
  static updateContactfield(
    params: {
      /** id of the contact field */
      contactCustomFieldId: number;
      /** requestBody */
      body?: Model_ContactCustomFieldUpdate;
    } = {} as any,
    options: IRequestOptions = {}
  ): Promise<Model_ContactCustomFieldResponse> {
    return new Promise((resolve, reject) => {
      let url = basePath + "/ContactCustomField/{contactCustomFieldId}";
      url = url.replace(
        "{contactCustomFieldId}",
        params["contactCustomFieldId"] + ""
      );

      const configs: IRequestConfig = getConfigs(
        "put",
        "application/json",
        url,
        options
      );

      let data = params.body;

      configs.data = data;

      axios(configs, resolve, reject);
    });
  }
  /**
   * delete a contact field
   */
  static deleteContactCustomFieldId(
    params: {
      /** Id of contact field */
      contactCustomFieldId: number;
    } = {} as any,
    options: IRequestOptions = {}
  ): Promise<any> {
    return new Promise((resolve, reject) => {
      let url = basePath + "/ContactCustomField/{contactCustomFieldId}";
      url = url.replace(
        "{contactCustomFieldId}",
        params["contactCustomFieldId"] + ""
      );

      const configs: IRequestConfig = getConfigs(
        "delete",
        "application/json",
        url,
        options
      );

      let data = null;

      configs.data = data;

      axios(configs, resolve, reject);
    });
  }
  /**
   * Retrieve contact field settings
   */
  static getContactFieldSettings(
    options: IRequestOptions = {}
  ): Promise<any | null> {
    return new Promise((resolve, reject) => {
      let url = basePath + "/ContactCustomFieldSetting";

      const configs: IRequestConfig = getConfigs(
        "get",
        "application/json",
        url,
        options
      );

      axios(configs, resolve, reject);
    });
  }
  /**
   * Create contact field setting
   */
  static createContactFieldSetting(
    params: {
      /** requestBody */
      body?: Model_ContactCustomFieldSetting;
    } = {} as any,
    options: IRequestOptions = {}
  ): Promise<any | null> {
    return new Promise((resolve, reject) => {
      let url = basePath + "/ContactCustomFieldSetting";

      const configs: IRequestConfig = getConfigs(
        "post",
        "application/json",
        url,
        options
      );

      let data = params.body;

      configs.data = data;

      axios(configs, resolve, reject);
    });
  }
  /**
   * Find contact field setting by ID
   */
  static getContactFieldSettingById(
    params: {
      /** ID of contact field to return */
      contactCustomFieldSettingId: number;
    } = {} as any,
    options: IRequestOptions = {}
  ): Promise<any | null> {
    return new Promise((resolve, reject) => {
      let url =
        basePath + "/ContactCustomFieldSetting/{contactCustomFieldSettingId}";
      url = url.replace(
        "{contactCustomFieldSettingId}",
        params["contactCustomFieldSettingId"] + ""
      );

      const configs: IRequestConfig = getConfigs(
        "get",
        "application/json",
        url,
        options
      );

      axios(configs, resolve, reject);
    });
  }
  /**
   * Update contact field setting
   */
  static updateContactFieldSetting(
    params: {
      /** ID of contact field setting you want to update */
      contactCustomFieldSettingId: number;
      /** requestBody */
      body?: Model_ContactCustomFieldSettingUpdate;
    } = {} as any,
    options: IRequestOptions = {}
  ): Promise<Model_ContactCustomFieldSettingResponse> {
    return new Promise((resolve, reject) => {
      let url =
        basePath + "/ContactCustomFieldSetting/{contactCustomFieldSettingId}";
      url = url.replace(
        "{contactCustomFieldSettingId}",
        params["contactCustomFieldSettingId"] + ""
      );

      const configs: IRequestConfig = getConfigs(
        "put",
        "application/json",
        url,
        options
      );

      let data = params.body;

      configs.data = data;

      axios(configs, resolve, reject);
    });
  }
  /**
   * Deletes a contact field setting
   */
  static deleteContactFieldSetting(
    params: {
      /** Id of contact field to delete */
      contactCustomFieldSettingId: number;
    } = {} as any,
    options: IRequestOptions = {}
  ): Promise<any> {
    return new Promise((resolve, reject) => {
      let url =
        basePath + "/ContactCustomFieldSetting/{contactCustomFieldSettingId}";
      url = url.replace(
        "{contactCustomFieldSettingId}",
        params["contactCustomFieldSettingId"] + ""
      );

      const configs: IRequestConfig = getConfigs(
        "delete",
        "application/json",
        url,
        options
      );

      let data = null;

      configs.data = data;

      axios(configs, resolve, reject);
    });
  }
  /**
   * Receive count reference
   */
  static getReferenceCount(
    params: {
      /** ID of contact field you want to get the reference count */
      contactCustomFieldSettingId: number;
    } = {} as any,
    options: IRequestOptions = {}
  ): Promise<any> {
    return new Promise((resolve, reject) => {
      let url =
        basePath +
        "/ContactCustomFieldSetting/{contactCustomFieldSettingId}/getReferenceCount";
      url = url.replace(
        "{contactCustomFieldSettingId}",
        params["contactCustomFieldSettingId"] + ""
      );

      const configs: IRequestConfig = getConfigs(
        "get",
        "application/json",
        url,
        options
      );

      axios(configs, resolve, reject);
    });
  }
}

export class CreditNoteService {
  /**
   * Retrieve CreditNote
   */
  static getCreditNotes(
    params: {
      /** Status of the CreditNote */
      status?: string;
      /** Retrieve all CreditNotes with this creditNote number */
      creditNoteNumber?: string;
      /** Retrieve all CreditNotes with a date equal or higher */
      startDate?: number;
      /** Retrieve all CreditNotes with a date equal or lower */
      endDate?: number;
    } = {} as any,
    options: IRequestOptions = {}
  ): Promise<any> {
    return new Promise((resolve, reject) => {
      let url = basePath + "/CreditNote";

      const configs: IRequestConfig = getConfigs(
        "get",
        "application/json",
        url,
        options
      );
      configs.params = {
        status: params["status"],
        creditNoteNumber: params["creditNoteNumber"],
        startDate: params["startDate"],
        endDate: params["endDate"],
      };

      axios(configs, resolve, reject);
    });
  }
  /**
   * Create a new creditNote
   */
  static createcreditNote(
    params: {
      /** requestBody */
      body?: saveCreditNote;
    } = {} as any,
    options: IRequestOptions = {}
  ): Promise<saveCreditNoteResponse> {
    return new Promise((resolve, reject) => {
      let url = basePath + "/CreditNote/Factory/saveCreditNote";

      const configs: IRequestConfig = getConfigs(
        "post",
        "application/json",
        url,
        options
      );

      let data = params.body;

      configs.data = data;

      axios(configs, resolve, reject);
    });
  }
  /**
   * Creates a new creditNote from an invoice
   */
  static createCreditNoteFromInvoice(
    options: IRequestOptions = {}
  ): Promise<any> {
    return new Promise((resolve, reject) => {
      let url = basePath + "/CreditNote/Factory/createFromInvoice";

      const configs: IRequestConfig = getConfigs(
        "post",
        "application/json",
        url,
        options
      );

      let data = null;

      configs.data = data;

      axios(configs, resolve, reject);
    });
  }
  /**
   * Creates a new creditNote from a voucher
   */
  static createCreditNoteFromVoucher(
    options: IRequestOptions = {}
  ): Promise<any> {
    return new Promise((resolve, reject) => {
      let url = basePath + "/CreditNote/Factory/createFromVoucher";

      const configs: IRequestConfig = getConfigs(
        "post",
        "application/json",
        url,
        options
      );

      let data = null;

      configs.data = data;

      axios(configs, resolve, reject);
    });
  }
  /**
   * Find creditNote by ID
   */
  static getcreditNoteById(
    params: {
      /** ID of creditNote to return */
      creditNoteId: number;
    } = {} as any,
    options: IRequestOptions = {}
  ): Promise<any> {
    return new Promise((resolve, reject) => {
      let url = basePath + "/CreditNote/{creditNoteId}";
      url = url.replace("{creditNoteId}", params["creditNoteId"] + "");

      const configs: IRequestConfig = getConfigs(
        "get",
        "application/json",
        url,
        options
      );

      axios(configs, resolve, reject);
    });
  }
  /**
   * Update an existing creditNote
   */
  static updatecreditNote(
    params: {
      /** ID of creditNote to update */
      creditNoteId: number;
      /** requestBody */
      body?: Model_creditNoteUpdate;
    } = {} as any,
    options: IRequestOptions = {}
  ): Promise<Model_creditNoteResponse> {
    return new Promise((resolve, reject) => {
      let url = basePath + "/CreditNote/{creditNoteId}";
      url = url.replace("{creditNoteId}", params["creditNoteId"] + "");

      const configs: IRequestConfig = getConfigs(
        "put",
        "application/json",
        url,
        options
      );

      let data = params.body;

      configs.data = data;

      axios(configs, resolve, reject);
    });
  }
  /**
   * Deletes an creditNote
   */
  static deletecreditNote(
    params: {
      /** Id of creditNote resource to delete */
      creditNoteId: number;
    } = {} as any,
    options: IRequestOptions = {}
  ): Promise<any> {
    return new Promise((resolve, reject) => {
      let url = basePath + "/CreditNote/{creditNoteId}";
      url = url.replace("{creditNoteId}", params["creditNoteId"] + "");

      const configs: IRequestConfig = getConfigs(
        "delete",
        "application/json",
        url,
        options
      );

      let data = null;

      configs.data = data;

      axios(configs, resolve, reject);
    });
  }
  /**
   * Send credit note by printing
   */
  static sendCreditNoteByPrinting(
    params: {
      /** ID of creditNote to return */
      creditNoteId: number;
      /** the type you want to print. */
      sendType: string;
    } = {} as any,
    options: IRequestOptions = {}
  ): Promise<Model_CreditNote_sendByWithRender> {
    return new Promise((resolve, reject) => {
      let url = basePath + "/CreditNote/{creditNoteId}/sendByWithRender";
      url = url.replace("{creditNoteId}", params["creditNoteId"] + "");

      const configs: IRequestConfig = getConfigs(
        "get",
        "application/json",
        url,
        options
      );
      configs.params = { sendType: params["sendType"] };

      axios(configs, resolve, reject);
    });
  }
  /**
   * Mark credit note as sent
   */
  static creditNoteSendBy(
    params: {
      /** ID of credit note to mark as sent */
      creditNoteId: number;
    } = {} as any,
    options: IRequestOptions = {}
  ): Promise<Model_creditNoteResponse> {
    return new Promise((resolve, reject) => {
      let url = basePath + "/CreditNote/{creditNoteId}/sendBy";
      url = url.replace("{creditNoteId}", params["creditNoteId"] + "");

      const configs: IRequestConfig = getConfigs(
        "put",
        "application/json",
        url,
        options
      );

      let data = null;

      configs.data = data;

      axios(configs, resolve, reject);
    });
  }
  /**
   * Retrieve pdf document of a credit note
   */
  static creditNoteGetPdf(
    params: {
      /** ID of credit note from which you want the pdf */
      creditNoteId: number;
      /** If u want to download the pdf of the credit note. */
      download?: boolean;
      /** Defines if u want to send the credit note. */
      preventSendBy?: boolean;
    } = {} as any,
    options: IRequestOptions = {}
  ): Promise<any> {
    return new Promise((resolve, reject) => {
      let url = basePath + "/CreditNote/{creditNoteId}/getPdf";
      url = url.replace("{creditNoteId}", params["creditNoteId"] + "");

      const configs: IRequestConfig = getConfigs(
        "get",
        "application/json",
        url,
        options
      );
      configs.params = {
        download: params["download"],
        preventSendBy: params["preventSendBy"],
      };

      axios(configs, resolve, reject);
    });
  }
  /**
   * Send credit note via email
   */
  static sendCreditNoteViaEMail(
    params: {
      /** ID of credit note to be sent via email */
      creditNoteId: number;
    } = {} as any,
    options: IRequestOptions = {}
  ): Promise<any> {
    return new Promise((resolve, reject) => {
      let url = basePath + "/CreditNote/{creditNoteId}/sendViaEmail";
      url = url.replace("{creditNoteId}", params["creditNoteId"] + "");

      const configs: IRequestConfig = getConfigs(
        "post",
        "application/json",
        url,
        options
      );

      let data = null;

      configs.data = data;

      axios(configs, resolve, reject);
    });
  }
  /**
   * Book a credit note
   */
  static bookCreditNote(
    params: {
      /** ID of credit note to book */
      creditNoteId: number;
    } = {} as any,
    options: IRequestOptions = {}
  ): Promise<any> {
    return new Promise((resolve, reject) => {
      let url = basePath + "/CreditNote/{creditNoteId}/bookAmount";
      url = url.replace("{creditNoteId}", params["creditNoteId"] + "");

      const configs: IRequestConfig = getConfigs(
        "put",
        "application/json",
        url,
        options
      );

      let data = null;

      configs.data = data;

      axios(configs, resolve, reject);
    });
  }
}

export class ExportService {
  /**
   * Update export config
   */
  static updateExportConfig(
    params: {
      /** id of sevClient */
      sevClientId: number;
    } = {} as any,
    options: IRequestOptions = {}
  ): Promise<any> {
    return new Promise((resolve, reject) => {
      let url = basePath + "/SevClient/{SevClientId}/updateExportConfig";
      url = url.replace("{SevClientId}", params["sevClientId"] + "");

      const configs: IRequestConfig = getConfigs(
        "put",
        "application/json",
        url,
        options
      );

      let data = null;

      configs.data = data;

      axios(configs, resolve, reject);
    });
  }
  /**
   * Export datev
   */
  static exportDatev(
    params: {
      /** Specifies if the document is downloaded */
      download?: boolean;
      /** the start date of the export as timestamp */
      startDate: number;
      /** the end date of the export as timestamp */
      endDate: number;
      /** Define what you want to include in the datev export. This parameter takes a string of  5 letters. Each stands for a model that should be included. Possible letters are: ‘E’ (Earnings), ‘X’ (Expenditure), ‘T’ (Transactions), ‘C’ (Cashregister), ‘D’ (Assets). By providing one of those letter you specify that it should be included in the datev export. Some combinations are: ‘EXTCD’, ‘EXTD’ … */
      scope: string;
      /** include unpaid documents */
      withUnpaidDocuments?: boolean;
      /** include enshrined documents */
      withEnshrinedDocuments?: boolean;
      /** Specify if you want to enshrine all models which were included in the export */
      enshrine?: boolean;
    } = {} as any,
    options: IRequestOptions = {}
  ): Promise<any> {
    return new Promise((resolve, reject) => {
      let url = basePath + "/Export/datevCSV";

      const configs: IRequestConfig = getConfigs(
        "get",
        "application/json",
        url,
        options
      );
      configs.params = {
        Download: params["download"],
        startDate: params["startDate"],
        endDate: params["endDate"],
        scope: params["scope"],
        withUnpaidDocuments: params["withUnpaidDocuments"],
        withEnshrinedDocuments: params["withEnshrinedDocuments"],
        enshrine: params["enshrine"],
      };

      axios(configs, resolve, reject);
    });
  }
  /**
   * Export invoice
   */
  static exportInvoice(
    params: {
      /**  */
      download?: boolean;
      /**  */
      sevQuery: object;
    } = {} as any,
    options: IRequestOptions = {}
  ): Promise<any> {
    return new Promise((resolve, reject) => {
      let url = basePath + "/Export/invoiceCsv";

      const configs: IRequestConfig = getConfigs(
        "get",
        "application/json",
        url,
        options
      );
      configs.params = {
        download: params["download"],
        sevQuery: params["sevQuery"],
      };

      axios(configs, resolve, reject);
    });
  }
  /**
   * Export Invoice as zip
   */
  static exportInvoiceZip(
    params: {
      /**  */
      download?: boolean;
      /**  */
      sevQuery: object;
    } = {} as any,
    options: IRequestOptions = {}
  ): Promise<any> {
    return new Promise((resolve, reject) => {
      let url = basePath + "/Export/invoiceZip";

      const configs: IRequestConfig = getConfigs(
        "get",
        "application/json",
        url,
        options
      );
      configs.params = {
        download: params["download"],
        sevQuery: params["sevQuery"],
      };

      axios(configs, resolve, reject);
    });
  }
  /**
   * Export creditNote
   */
  static exportCreditNote(
    params: {
      /**  */
      download?: boolean;
      /**  */
      sevQuery: object;
    } = {} as any,
    options: IRequestOptions = {}
  ): Promise<any> {
    return new Promise((resolve, reject) => {
      let url = basePath + "/Export/creditNoteCsv";

      const configs: IRequestConfig = getConfigs(
        "get",
        "application/json",
        url,
        options
      );
      configs.params = {
        download: params["download"],
        sevQuery: params["sevQuery"],
      };

      axios(configs, resolve, reject);
    });
  }
  /**
   * Export voucher as zip
   */
  static exportVoucher(
    params: {
      /**  */
      download?: boolean;
      /**  */
      sevQuery: object;
    } = {} as any,
    options: IRequestOptions = {}
  ): Promise<any> {
    return new Promise((resolve, reject) => {
      let url = basePath + "/Export/voucherListCsv";

      const configs: IRequestConfig = getConfigs(
        "get",
        "application/json",
        url,
        options
      );
      configs.params = {
        download: params["download"],
        sevQuery: params["sevQuery"],
      };

      axios(configs, resolve, reject);
    });
  }
  /**
   * Export transaction
   */
  static exportTransactions(
    params: {
      /**  */
      download?: boolean;
      /**  */
      sevQuery: object;
    } = {} as any,
    options: IRequestOptions = {}
  ): Promise<any> {
    return new Promise((resolve, reject) => {
      let url = basePath + "/Export/transactionsCsv";

      const configs: IRequestConfig = getConfigs(
        "get",
        "application/json",
        url,
        options
      );
      configs.params = {
        download: params["download"],
        sevQuery: params["sevQuery"],
      };

      axios(configs, resolve, reject);
    });
  }
  /**
   * Export voucher zip
   */
  static exportVoucherZip(
    params: {
      /**  */
      download?: boolean;
      /**  */
      sevQuery: object;
    } = {} as any,
    options: IRequestOptions = {}
  ): Promise<any> {
    return new Promise((resolve, reject) => {
      let url = basePath + "/Export/voucherZip";

      const configs: IRequestConfig = getConfigs(
        "get",
        "application/json",
        url,
        options
      );
      configs.params = {
        download: params["download"],
        sevQuery: params["sevQuery"],
      };

      axios(configs, resolve, reject);
    });
  }
  /**
   * Export contact
   */
  static exportContact(
    params: {
      /**  */
      download?: boolean;
      /**  */
      sevQuery: object;
    } = {} as any,
    options: IRequestOptions = {}
  ): Promise<any> {
    return new Promise((resolve, reject) => {
      let url = basePath + "/Export/contactListCsv";

      const configs: IRequestConfig = getConfigs(
        "get",
        "application/json",
        url,
        options
      );
      configs.params = {
        download: params["download"],
        sevQuery: params["sevQuery"],
      };

      axios(configs, resolve, reject);
    });
  }
}

export class PartService {
  /**
   * Retrieve parts
   */
  static getParts(
    params: {
      /** Retrieve all parts with this part number */
      partNumber?: string;
      /** Retrieve all parts with this name */
      name?: string;
    } = {} as any,
    options: IRequestOptions = {}
  ): Promise<any> {
    return new Promise((resolve, reject) => {
      let url = basePath + "/Part";

      const configs: IRequestConfig = getConfigs(
        "get",
        "application/json",
        url,
        options
      );
      configs.params = {
        partNumber: params["partNumber"],
        name: params["name"],
      };

      axios(configs, resolve, reject);
    });
  }
  /**
   * Create a new part
   */
  static createPart(
    params: {
      /** requestBody */
      body?: Model_Part;
    } = {} as any,
    options: IRequestOptions = {}
  ): Promise<Model_Part> {
    return new Promise((resolve, reject) => {
      let url = basePath + "/Part";

      const configs: IRequestConfig = getConfigs(
        "post",
        "application/json",
        url,
        options
      );

      let data = params.body;

      configs.data = data;

      axios(configs, resolve, reject);
    });
  }
  /**
   * Find part by ID
   */
  static getPartById(
    params: {
      /** ID of part to return */
      partId: number;
    } = {} as any,
    options: IRequestOptions = {}
  ): Promise<any> {
    return new Promise((resolve, reject) => {
      let url = basePath + "/Part/{partId}";
      url = url.replace("{partId}", params["partId"] + "");

      const configs: IRequestConfig = getConfigs(
        "get",
        "application/json",
        url,
        options
      );

      axios(configs, resolve, reject);
    });
  }
  /**
   * Update an existing part
   */
  static updatePart(
    params: {
      /** ID of part to update */
      partId: number;
      /** requestBody */
      body?: Model_PartUpdate;
    } = {} as any,
    options: IRequestOptions = {}
  ): Promise<Model_Part> {
    return new Promise((resolve, reject) => {
      let url = basePath + "/Part/{partId}";
      url = url.replace("{partId}", params["partId"] + "");

      const configs: IRequestConfig = getConfigs(
        "put",
        "application/json",
        url,
        options
      );

      let data = params.body;

      configs.data = data;

      axios(configs, resolve, reject);
    });
  }
  /**
   * Get stock of a part
   */
  static partGetStock(
    params: {
      /** ID of part for which you want the current stock. */
      partId: number;
    } = {} as any,
    options: IRequestOptions = {}
  ): Promise<any> {
    return new Promise((resolve, reject) => {
      let url = basePath + "/Part/{partId}/getStock";
      url = url.replace("{partId}", params["partId"] + "");

      const configs: IRequestConfig = getConfigs(
        "get",
        "application/json",
        url,
        options
      );

      axios(configs, resolve, reject);
    });
  }
}

export class InvoiceService {
  /**
   * Retrieve invoices
   */
  static getInvoices(
    params: {
      /** Status of the invoices */
      status?: number;
      /** Retrieve all invoices with this invoice number */
      invoiceNumber?: string;
      /** Retrieve all invoices with a date equal or higher */
      startDate?: number;
      /** Retrieve all invoices with a date equal or lower */
      endDate?: number;
    } = {} as any,
    options: IRequestOptions = {}
  ): Promise<ObjectsWrapper<Array<Model_InvoiceResponse>>> {
    return new Promise((resolve, reject) => {
      let url = basePath + "/Invoice";

      const configs: IRequestConfig = getConfigs(
        "get",
        "application/json",
        url,
        options
      );
      configs.params = {
        status: params["status"],
        invoiceNumber: params["invoiceNumber"],
        startDate: params["startDate"],
        endDate: params["endDate"],
      };

      axios(configs, resolve, reject);
    });
  }
  /**
   * Create a new invoice
   */
  static createInvoiceByFactory(
    params: {
      /** requestBody */
      body?: saveInvoice;
    } = {} as any,
    options: IRequestOptions = {}
  ): Promise<ObjectsWrapper<saveInvoiceResponse>> {
    return new Promise((resolve, reject) => {
      let url = basePath + "/Invoice/Factory/saveInvoice";

      const configs: IRequestConfig = getConfigs(
        "post",
        "application/json",
        url,
        options
      );

      let data = params.body;

      configs.data = data;

      axios(configs, resolve, reject);
    });
  }
  /**
   * Find invoice by ID
   * NOTE: API returns an array, instead of just single object
   */
  static getInvoiceById(
    params: {
      /** ID of invoice to return */
      invoiceId: number;
    } = {} as any,
    options: IRequestOptions = {}
  ): Promise<ObjectsWrapper<Array<Model_InvoiceResponse>>> {
    return new Promise((resolve, reject) => {
      let url = basePath + "/Invoice/{invoiceId}";
      url = url.replace("{invoiceId}", params["invoiceId"] + "");

      const configs: IRequestConfig = getConfigs(
        "get",
        "application/json",
        url,
        options
      );

      axios(configs, resolve, reject);
    });
  }
  /**
   * Find invoice positions
   */
  static getInvoicePositionsById(
    params: {
      /** ID of invoice to return the positions */
      invoiceId: number;
      /** limits the number of entries returned */
      limit?: number;
      /** set the index where the returned entries start */
      offset?: number;
      /** Get some additional information. Embed can handle multiple values, they must be separated by comma. */
      embed?: any | null[];
    } = {} as any,
    options: IRequestOptions = {}
  ): Promise<ObjectsWrapper<Array<Model_InvoicePosResponse>>> {
    return new Promise((resolve, reject) => {
      let url = basePath + "/Invoice/{invoiceId}/getPositions";
      url = url.replace("{invoiceId}", params["invoiceId"] + "");

      const configs: IRequestConfig = getConfigs(
        "get",
        "application/json",
        url,
        options
      );
      configs.params = {
        limit: params["limit"],
        offset: params["offset"],
        embed: params["embed"],
      };

      axios(configs, resolve, reject);
    });
  }
  /**
   * Create invoice from order
   */
  static createInvoiceFromOrder(
    params: {
      /** requestBody */
      body?: Model_CreateInvoiceFromOrder;
    } = {} as any,
    options: IRequestOptions = {}
  ): Promise<Model_InvoiceResponse> {
    return new Promise((resolve, reject) => {
      let url = basePath + "/Invoice/Factory/createInvoiceFromOrder";

      const configs: IRequestConfig = getConfigs(
        "post",
        "application/json",
        url,
        options
      );

      let data = params.body;

      configs.data = data;

      axios(configs, resolve, reject);
    });
  }
  /**
   * Create invoice reminder
   */
  static createInvoiceReminder(
    options: IRequestOptions = {}
  ): Promise<Model_InvoiceResponse> {
    return new Promise((resolve, reject) => {
      let url = basePath + "/Invoice/Factory/createInvoiceReminder";

      const configs: IRequestConfig = getConfigs(
        "post",
        "application/json",
        url,
        options
      );

      let data = null;

      configs.data = data;

      axios(configs, resolve, reject);
    });
  }
  /**
   * Check if an invoice is already partially paid
   */
  static getIsInvoicePartiallyPaid(
    params: {
      /** ID of invoice to return */
      invoiceId: number;
    } = {} as any,
    options: IRequestOptions = {}
  ): Promise<any> {
    return new Promise((resolve, reject) => {
      let url = basePath + "/Invoice/{invoiceId}/getIsPartiallyPaid";
      url = url.replace("{invoiceId}", params["invoiceId"] + "");

      const configs: IRequestConfig = getConfigs(
        "get",
        "application/json",
        url,
        options
      );

      axios(configs, resolve, reject);
    });
  }
  /**
   * Cancel an invoice / Create cancellation invoice
   */
  static cancelInvoice(
    params: {
      /** ID of invoice to be cancelled */
      invoiceId: number;
    } = {} as any,
    options: IRequestOptions = {}
  ): Promise<Model_InvoiceResponse> {
    return new Promise((resolve, reject) => {
      let url = basePath + "/Invoice/{invoiceId}/cancelInvoice";
      url = url.replace("{invoiceId}", params["invoiceId"] + "");

      const configs: IRequestConfig = getConfigs(
        "post",
        "application/json",
        url,
        options
      );

      let data = null;

      configs.data = data;

      axios(configs, resolve, reject);
    });
  }
  /**
   * Render the pdf document of an invoice
   */
  static invoiceRender(
    params: {
      /** ID of invoice to render */
      invoiceId: number;
    } = {} as any,
    options: IRequestOptions = {}
  ): Promise<any | null> {
    return new Promise((resolve, reject) => {
      let url = basePath + "/Invoice/{invoiceId}/render";
      url = url.replace("{invoiceId}", params["invoiceId"] + "");

      const configs: IRequestConfig = getConfigs(
        "post",
        "application/json",
        url,
        options
      );

      let data = null;

      configs.data = data;

      axios(configs, resolve, reject);
    });
  }
  /**
   * Send invoice via email
   */
  static sendInvoiceViaEMail(
    params: {
      /** ID of invoice to be sent via email */
      invoiceId: number;
      /** requestBody */
      body?: Model_SendInvoiceViaEMail;
    } = {} as any,
    options: IRequestOptions = {}
  ): Promise<Model_Email> {
    return new Promise((resolve, reject) => {
      let url = basePath + "/Invoice/{invoiceId}/sendViaEmail";
      url = url.replace("{invoiceId}", params["invoiceId"] + "");

      const configs: IRequestConfig = getConfigs(
        "post",
        "application/json",
        url,
        options
      );

      let data = params.body;

      configs.data = data;

      axios(configs, resolve, reject);
    });
  }
  /**
   * Retrieve pdf document of an invoice
   */
  static invoiceGetPdf(
    params: {
      /** ID of invoice from which you want the pdf */
      invoiceId: number;
      /** If u want to download the pdf of the invoice. */
      download?: boolean;
      /** Defines if u want to send the invoice. */
      preventSendBy?: boolean;
    } = {} as any,
    options: IRequestOptions = {}
  ): Promise<any> {
    return new Promise((resolve, reject) => {
      let url = basePath + "/Invoice/{invoiceId}/getPdf";
      url = url.replace("{invoiceId}", params["invoiceId"] + "");

      const configs: IRequestConfig = getConfigs(
        "get",
        "application/json",
        url,
        options
      );
      configs.params = {
        download: params["download"],
        preventSendBy: params["preventSendBy"],
      };

      axios(configs, resolve, reject);
    });
  }
  /**
   * Mark invoice as sent
   */
  static invoiceSendBy(
    params: {
      /** ID of invoice to mark as sent */
      invoiceId: number;
    } = {} as any,
    options: IRequestOptions = {}
  ): Promise<Model_InvoiceResponse> {
    return new Promise((resolve, reject) => {
      let url = basePath + "/Invoice/{invoiceId}/sendBy";
      url = url.replace("{invoiceId}", params["invoiceId"] + "");

      const configs: IRequestConfig = getConfigs(
        "put",
        "application/json",
        url,
        options
      );

      let data = null;

      configs.data = data;

      axios(configs, resolve, reject);
    });
  }
  /**
   * Book an invoice
   */
  static bookInvoice(
    params: {
      /** ID of invoice to book */
      invoiceId: number;
    } = {} as any,
    options: IRequestOptions = {}
  ): Promise<any> {
    return new Promise((resolve, reject) => {
      let url = basePath + "/Invoice/{invoiceId}/bookAmount";
      url = url.replace("{invoiceId}", params["invoiceId"] + "");

      const configs: IRequestConfig = getConfigs(
        "put",
        "application/json",
        url,
        options
      );

      let data = null;

      configs.data = data;

      axios(configs, resolve, reject);
    });
  }
  /**
   * Activate Auto Sending of an invoice (mainly useful for repeating invoices)
   * NOTE: this endpoint is not listed in the official API docs but can be observed when using the frontend
   */
  static activateAutoSending(
    params: {
      /** ID of invoice to activate auto sending for */
      invoiceId: number;
      /** requestBody */
      body?: Model_InvoiceActivateAutoSending;
    } = {} as any,
    options: IRequestOptions = {}
  ): Promise<any> {
    return new Promise((resolve, reject) => {
      let url = basePath + "/Invoice/{invoiceId}/activateAutoSending";
      url = url.replace("{invoiceId}", params["invoiceId"] + "");

      const configs: IRequestConfig = getConfigs(
        "post",
        "application/json",
        url,
        options
      );

      let data = params.body;

      configs.data = data;

      axios(configs, resolve, reject);
    });
  }
}

export class InvoicePosService {
  /**
   * Retrieve InvoicePos
   */
  static getInvoicePos(
    params: {
      /** Retrieve all InvoicePos with this InvoicePos id */
      id?: number;
    } = {} as any,
    options: IRequestOptions = {}
  ): Promise<any> {
    return new Promise((resolve, reject) => {
      let url = basePath + "/InvoicePos";

      const configs: IRequestConfig = getConfigs(
        "get",
        "application/json",
        url,
        options
      );
      configs.params = { id: params["id"] };

      axios(configs, resolve, reject);
    });
  }
}

export class LayoutService {
  /**
   * Retrieve letterpapers
   */
  static getLetterpapersWithThumb(
    options: IRequestOptions = {}
  ): Promise<any | null> {
    return new Promise((resolve, reject) => {
      let url = basePath + "/DocServer/getLetterpapersWithThumb";

      const configs: IRequestConfig = getConfigs(
        "get",
        "application/json",
        url,
        options
      );

      axios(configs, resolve, reject);
    });
  }
  /**
   * Retrieve templates
   */
  static getTemplates(
    params: {
      /** Type of the templates you want to get. */
      type?: string;
    } = {} as any,
    options: IRequestOptions = {}
  ): Promise<any | null> {
    return new Promise((resolve, reject) => {
      let url = basePath + "/DocServer/getTemplatesWithThumb";

      const configs: IRequestConfig = getConfigs(
        "get",
        "application/json",
        url,
        options
      );
      configs.params = { type: params["type"] };

      axios(configs, resolve, reject);
    });
  }
  /**
   * Update an invoice template
   */
  static updateInvoiceTemplate(
    params: {
      /** ID of invoice to update */
      invoiceId: number;
      /** requestBody */
      body?: Model_ChangeLayout;
    } = {} as any,
    options: IRequestOptions = {}
  ): Promise<Model_ChangeLayoutResponse> {
    return new Promise((resolve, reject) => {
      let url = basePath + "/Invoice/{invoiceId}/changeParameter";
      url = url.replace("{invoiceId}", params["invoiceId"] + "");

      const configs: IRequestConfig = getConfigs(
        "put",
        "application/json",
        url,
        options
      );

      let data = params.body;

      configs.data = data;

      axios(configs, resolve, reject);
    });
  }
  /**
   * Update an order template
   */
  static updateOrderTemplate(
    params: {
      /** ID of order to update */
      orderId: number;
      /** requestBody */
      body?: Model_ChangeLayout;
    } = {} as any,
    options: IRequestOptions = {}
  ): Promise<Model_ChangeLayoutResponse> {
    return new Promise((resolve, reject) => {
      let url = basePath + "/Order/{orderId}/changeParameter";
      url = url.replace("{orderId}", params["orderId"] + "");

      const configs: IRequestConfig = getConfigs(
        "put",
        "application/json",
        url,
        options
      );

      let data = params.body;

      configs.data = data;

      axios(configs, resolve, reject);
    });
  }
  /**
   * Update an of credit note template
   */
  static updateCreditNoteTemplate(
    params: {
      /** ID of credit note to update */
      creditNoteId: number;
      /** requestBody */
      body?: Model_ChangeLayout;
    } = {} as any,
    options: IRequestOptions = {}
  ): Promise<Model_ChangeLayoutResponse> {
    return new Promise((resolve, reject) => {
      let url = basePath + "/CreditNote/{creditNoteId}/changeParameter";
      url = url.replace("{creditNoteId}", params["creditNoteId"] + "");

      const configs: IRequestConfig = getConfigs(
        "put",
        "application/json",
        url,
        options
      );

      let data = params.body;

      configs.data = data;

      axios(configs, resolve, reject);
    });
  }
}

export class OrderService {
  /**
   * Retrieve orders
   */
  static getOrders(
    params: {
      /** Status of the order */
      status?: number;
      /** Retrieve all orders with this order number */
      orderNumber?: string;
      /** Retrieve all orders with a date equal or higher */
      startDate?: number;
      /** Retrieve all orders with a date equal or lower */
      endDate?: number;
    } = {} as any,
    options: IRequestOptions = {}
  ): Promise<any> {
    return new Promise((resolve, reject) => {
      let url = basePath + "/Order";

      const configs: IRequestConfig = getConfigs(
        "get",
        "application/json",
        url,
        options
      );
      configs.params = {
        status: params["status"],
        orderNumber: params["orderNumber"],
        startDate: params["startDate"],
        endDate: params["endDate"],
      };

      axios(configs, resolve, reject);
    });
  }
  /**
   * Create a new order
   */
  static createOrder(
    params: {
      /** requestBody */
      body?: saveOrder;
    } = {} as any,
    options: IRequestOptions = {}
  ): Promise<saveOrderResponse> {
    return new Promise((resolve, reject) => {
      let url = basePath + "/Order/Factory/saveOrder";

      const configs: IRequestConfig = getConfigs(
        "post",
        "application/json",
        url,
        options
      );

      let data = params.body;

      configs.data = data;

      axios(configs, resolve, reject);
    });
  }
  /**
   * Find order by ID
   */
  static getOrderById(
    params: {
      /** ID of order to return */
      orderId: number;
    } = {} as any,
    options: IRequestOptions = {}
  ): Promise<any> {
    return new Promise((resolve, reject) => {
      let url = basePath + "/Order/{orderId}";
      url = url.replace("{orderId}", params["orderId"] + "");

      const configs: IRequestConfig = getConfigs(
        "get",
        "application/json",
        url,
        options
      );

      axios(configs, resolve, reject);
    });
  }
  /**
   * Update an existing order
   */
  static updateOrder(
    params: {
      /** ID of order to update */
      orderId: number;
      /** requestBody */
      body?: Model_OrderUpdate;
    } = {} as any,
    options: IRequestOptions = {}
  ): Promise<Model_OrderResponse> {
    return new Promise((resolve, reject) => {
      let url = basePath + "/Order/{orderId}";
      url = url.replace("{orderId}", params["orderId"] + "");

      const configs: IRequestConfig = getConfigs(
        "put",
        "application/json",
        url,
        options
      );

      let data = params.body;

      configs.data = data;

      axios(configs, resolve, reject);
    });
  }
  /**
   * Deletes an order
   */
  static deleteOrder(
    params: {
      /** Id of order resource to delete */
      orderId: number;
    } = {} as any,
    options: IRequestOptions = {}
  ): Promise<any> {
    return new Promise((resolve, reject) => {
      let url = basePath + "/Order/{orderId}";
      url = url.replace("{orderId}", params["orderId"] + "");

      const configs: IRequestConfig = getConfigs(
        "delete",
        "application/json",
        url,
        options
      );

      let data = null;

      configs.data = data;

      axios(configs, resolve, reject);
    });
  }
  /**
   * Find order positions
   */
  static getOrderPositionsById(
    params: {
      /** ID of order to return the positions */
      orderId: number;
      /** limits the number of entries returned */
      limit?: number;
      /** set the index where the returned entries start */
      offset?: number;
      /** Get some additional information. Embed can handle multiple values, they must be separated by comma. */
      embed?: any | null[];
    } = {} as any,
    options: IRequestOptions = {}
  ): Promise<any> {
    return new Promise((resolve, reject) => {
      let url = basePath + "/Order/{orderId}/getPositions";
      url = url.replace("{orderId}", params["orderId"] + "");

      const configs: IRequestConfig = getConfigs(
        "get",
        "application/json",
        url,
        options
      );
      configs.params = {
        limit: params["limit"],
        offset: params["offset"],
        embed: params["embed"],
      };

      axios(configs, resolve, reject);
    });
  }
  /**
   * Find order discounts
   */
  static getDiscounts(
    params: {
      /** ID of order to return the positions */
      orderId: number;
      /** limits the number of entries returned */
      limit?: number;
      /** set the index where the returned entries start */
      offset?: number;
      /** Get some additional information. Embed can handle multiple values, they must be separated by comma. */
      embed?: any | null[];
    } = {} as any,
    options: IRequestOptions = {}
  ): Promise<any> {
    return new Promise((resolve, reject) => {
      let url = basePath + "/Order/{orderId}/getDiscounts";
      url = url.replace("{orderId}", params["orderId"] + "");

      const configs: IRequestConfig = getConfigs(
        "get",
        "application/json",
        url,
        options
      );
      configs.params = {
        limit: params["limit"],
        offset: params["offset"],
        embed: params["embed"],
      };

      axios(configs, resolve, reject);
    });
  }
  /**
   * Find related objects
   */
  static getRelatedObjects(
    params: {
      /** ID of order to return the positions */
      orderId: number;
      /** Define if the related objects include the order itself */
      includeItself?: boolean;
      /** Define if you want the related objects sorted by type */
      sortByType?: boolean;
      /** Get some additional information. Embed can handle multiple values, they must be separated by comma. */
      embed?: any | null[];
    } = {} as any,
    options: IRequestOptions = {}
  ): Promise<any> {
    return new Promise((resolve, reject) => {
      let url = basePath + "/Order/{orderId}/getRelatedObjects";
      url = url.replace("{orderId}", params["orderId"] + "");

      const configs: IRequestConfig = getConfigs(
        "get",
        "application/json",
        url,
        options
      );
      configs.params = {
        includeItself: params["includeItself"],
        sortByType: params["sortByType"],
        embed: params["embed"],
      };

      axios(configs, resolve, reject);
    });
  }
  /**
   * Send order via email
   */
  static sendorderViaEMail(
    params: {
      /** ID of order to be sent via email */
      orderId: number;
    } = {} as any,
    options: IRequestOptions = {}
  ): Promise<any> {
    return new Promise((resolve, reject) => {
      let url = basePath + "/Order/{orderId}/sendViaEmail";
      url = url.replace("{orderId}", params["orderId"] + "");

      const configs: IRequestConfig = getConfigs(
        "post",
        "application/json",
        url,
        options
      );

      let data = null;

      configs.data = data;

      axios(configs, resolve, reject);
    });
  }
  /**
   * Create packing list from order
   */
  static createPackingListFromOrder(
    params: {
      /** requestBody */
      body?: Model_CreatePackingListFromOrder;
    } = {} as any,
    options: IRequestOptions = {}
  ): Promise<Model_OrderResponse> {
    return new Promise((resolve, reject) => {
      let url = basePath + "/Order/Factory/createPackingListFromOrder";

      const configs: IRequestConfig = getConfigs(
        "post",
        "application/json",
        url,
        options
      );

      let data = params.body;

      configs.data = data;

      axios(configs, resolve, reject);
    });
  }
  /**
   * Create contract note from order
   */
  static createContractNoteFromOrder(
    params: {
      /** requestBody */
      body?: Model_CreatePackingListFromOrder;
    } = {} as any,
    options: IRequestOptions = {}
  ): Promise<Model_OrderResponse> {
    return new Promise((resolve, reject) => {
      let url = basePath + "/Order/Factory/createContractNoteFromOrder";

      const configs: IRequestConfig = getConfigs(
        "post",
        "application/json",
        url,
        options
      );

      let data = params.body;

      configs.data = data;

      axios(configs, resolve, reject);
    });
  }
  /**
   * Retrieve pdf document of an order
   */
  static orderGetPdf(
    params: {
      /** ID of order from which you want the pdf */
      orderId: number;
      /** If u want to download the pdf of the order. */
      download?: boolean;
      /** Defines if u want to send the order. */
      preventSendBy?: boolean;
    } = {} as any,
    options: IRequestOptions = {}
  ): Promise<any> {
    return new Promise((resolve, reject) => {
      let url = basePath + "/Order/{orderId}/getPdf";
      url = url.replace("{orderId}", params["orderId"] + "");

      const configs: IRequestConfig = getConfigs(
        "get",
        "application/json",
        url,
        options
      );
      configs.params = {
        download: params["download"],
        preventSendBy: params["preventSendBy"],
      };

      axios(configs, resolve, reject);
    });
  }
  /**
   * Mark order as sent
   */
  static orderSendBy(
    params: {
      /** ID of order to mark as sent */
      orderId: number;
    } = {} as any,
    options: IRequestOptions = {}
  ): Promise<Model_OrderResponse> {
    return new Promise((resolve, reject) => {
      let url = basePath + "/Order/{orderId}/sendBy";
      url = url.replace("{orderId}", params["orderId"] + "");

      const configs: IRequestConfig = getConfigs(
        "put",
        "application/json",
        url,
        options
      );

      let data = null;

      configs.data = data;

      axios(configs, resolve, reject);
    });
  }
}

export class OrderPosService {
  /**
   * Find order position by ID
   */
  static getOrderPositionById(
    params: {
      /** ID of order position to return */
      orderPosId: number;
    } = {} as any,
    options: IRequestOptions = {}
  ): Promise<any> {
    return new Promise((resolve, reject) => {
      let url = basePath + "/OrderPos/{orderPosId}";
      url = url.replace("{orderPosId}", params["orderPosId"] + "");

      const configs: IRequestConfig = getConfigs(
        "get",
        "application/json",
        url,
        options
      );

      axios(configs, resolve, reject);
    });
  }
  /**
   * Update an existing order position
   */
  static updateOrderPosition(
    params: {
      /** ID of order position to update */
      orderPosId: number;
      /** requestBody */
      body?: Model_OrderPosUpdate;
    } = {} as any,
    options: IRequestOptions = {}
  ): Promise<Model_OrderPosResponse> {
    return new Promise((resolve, reject) => {
      let url = basePath + "/OrderPos/{orderPosId}";
      url = url.replace("{orderPosId}", params["orderPosId"] + "");

      const configs: IRequestConfig = getConfigs(
        "put",
        "application/json",
        url,
        options
      );

      let data = params.body;

      configs.data = data;

      axios(configs, resolve, reject);
    });
  }
  /**
   * Deletes an order Position
   */
  static deleteOrderPos(
    params: {
      /** Id of order position resource to delete */
      orderPosId: number;
    } = {} as any,
    options: IRequestOptions = {}
  ): Promise<any> {
    return new Promise((resolve, reject) => {
      let url = basePath + "/OrderPos/{orderPosId}";
      url = url.replace("{orderPosId}", params["orderPosId"] + "");

      const configs: IRequestConfig = getConfigs(
        "delete",
        "application/json",
        url,
        options
      );

      let data = null;

      configs.data = data;

      axios(configs, resolve, reject);
    });
  }
}

export class VoucherService {
  /**
   * Create a new voucher
   */
  static createVoucherByFactory(
    params: {
      /** requestBody */
      body?: saveVoucher;
    } = {} as any,
    options: IRequestOptions = {}
  ): Promise<saveVoucherResponse> {
    return new Promise((resolve, reject) => {
      let url = basePath + "/Voucher/Factory/saveVoucher";

      const configs: IRequestConfig = getConfigs(
        "post",
        "application/json",
        url,
        options
      );

      let data = params.body;

      configs.data = data;

      axios(configs, resolve, reject);
    });
  }
  /**
   * Upload voucher file
   */
  static voucherUploadFile(options: IRequestOptions = {}): Promise<any> {
    return new Promise((resolve, reject) => {
      let url = basePath + "/Voucher/Factory/uploadTempFile";

      const configs: IRequestConfig = getConfigs(
        "post",
        "application/json",
        url,
        options
      );

      let data = null;

      configs.data = data;

      axios(configs, resolve, reject);
    });
  }
  /**
   * Retrieve vouchers
   */
  static getVouchers(
    params: {
      /** Status of the vouchers to retrieve. */
      status?: number;
      /** Define if you only want credit or debit vouchers. */
      creditDebit?: string;
      /** Retrieve all vouchers with a description like this. */
      descriptionLike?: string;
      /** Retrieve all vouchers with a date equal or higher */
      startDate?: number;
      /** Retrieve all vouchers with a date equal or lower */
      endDate?: number;
    } = {} as any,
    options: IRequestOptions = {}
  ): Promise<any> {
    return new Promise((resolve, reject) => {
      let url = basePath + "/Voucher";

      const configs: IRequestConfig = getConfigs(
        "get",
        "application/json",
        url,
        options
      );
      configs.params = {
        status: params["status"],
        creditDebit: params["creditDebit"],
        descriptionLike: params["descriptionLike"],
        startDate: params["startDate"],
        endDate: params["endDate"],
      };

      axios(configs, resolve, reject);
    });
  }
  /**
   * Find voucher by ID
   */
  static getVoucherById(
    params: {
      /** ID of voucher to return */
      voucherId: number;
    } = {} as any,
    options: IRequestOptions = {}
  ): Promise<any> {
    return new Promise((resolve, reject) => {
      let url = basePath + "/Voucher/{voucherId}";
      url = url.replace("{voucherId}", params["voucherId"] + "");

      const configs: IRequestConfig = getConfigs(
        "get",
        "application/json",
        url,
        options
      );

      axios(configs, resolve, reject);
    });
  }
  /**
   * Update an existing voucher
   */
  static updateVoucher(
    params: {
      /** ID of voucher to update */
      voucherId: number;
      /** requestBody */
      body?: Model_VoucherUpdate;
    } = {} as any,
    options: IRequestOptions = {}
  ): Promise<Model_VoucherResponse> {
    return new Promise((resolve, reject) => {
      let url = basePath + "/Voucher/{voucherId}";
      url = url.replace("{voucherId}", params["voucherId"] + "");

      const configs: IRequestConfig = getConfigs(
        "put",
        "application/json",
        url,
        options
      );

      let data = params.body;

      configs.data = data;

      axios(configs, resolve, reject);
    });
  }
  /**
   * Book a voucher
   */
  static bookVoucher(
    params: {
      /** ID of voucher to book */
      voucherId: number;
    } = {} as any,
    options: IRequestOptions = {}
  ): Promise<any> {
    return new Promise((resolve, reject) => {
      let url = basePath + "/Voucher/{voucherId}/bookAmount";
      url = url.replace("{voucherId}", params["voucherId"] + "");

      const configs: IRequestConfig = getConfigs(
        "put",
        "application/json",
        url,
        options
      );

      let data = null;

      configs.data = data;

      axios(configs, resolve, reject);
    });
  }
}

export class ReportService {
  /**
   * Export invoice list
   */
  static reportInvoice(
    params: {
      /**  */
      download?: boolean;
      /**  */
      view: string;
      /**  */
      sevQuery: object;
    } = {} as any,
    options: IRequestOptions = {}
  ): Promise<any> {
    return new Promise((resolve, reject) => {
      let url = basePath + "/Report/invoicelist";

      const configs: IRequestConfig = getConfigs(
        "get",
        "application/json",
        url,
        options
      );
      configs.params = {
        download: params["download"],
        view: params["view"],
        sevQuery: params["sevQuery"],
      };

      axios(configs, resolve, reject);
    });
  }
  /**
   * Export order list
   */
  static reportOrder(
    params: {
      /**  */
      download?: boolean;
      /**  */
      view: string;
      /**  */
      sevQuery: object;
    } = {} as any,
    options: IRequestOptions = {}
  ): Promise<any> {
    return new Promise((resolve, reject) => {
      let url = basePath + "/Report/orderlist";

      const configs: IRequestConfig = getConfigs(
        "get",
        "application/json",
        url,
        options
      );
      configs.params = {
        download: params["download"],
        view: params["view"],
        sevQuery: params["sevQuery"],
      };

      axios(configs, resolve, reject);
    });
  }
  /**
   * Export contact list
   */
  static reportContact(
    params: {
      /**  */
      download?: boolean;
      /**  */
      sevQuery: object;
    } = {} as any,
    options: IRequestOptions = {}
  ): Promise<any> {
    return new Promise((resolve, reject) => {
      let url = basePath + "/Report/contactlist";

      const configs: IRequestConfig = getConfigs(
        "get",
        "application/json",
        url,
        options
      );
      configs.params = {
        download: params["download"],
        sevQuery: params["sevQuery"],
      };

      axios(configs, resolve, reject);
    });
  }
  /**
   * Export voucher list
   */
  static reportVoucher(
    params: {
      /**  */
      download?: boolean;
      /**  */
      sevQuery: object;
    } = {} as any,
    options: IRequestOptions = {}
  ): Promise<any> {
    return new Promise((resolve, reject) => {
      let url = basePath + "/Report/voucherlist";

      const configs: IRequestConfig = getConfigs(
        "get",
        "application/json",
        url,
        options
      );
      configs.params = {
        download: params["download"],
        sevQuery: params["sevQuery"],
      };

      axios(configs, resolve, reject);
    });
  }
}

export class TagService {
  /**
   * Retrieve tags
   */
  static getTags(
    params: {
      /** ID of the Tag */
      id?: number;
      /** Name of the Tag */
      name?: string;
    } = {} as any,
    options: IRequestOptions = {}
  ): Promise<any | null> {
    return new Promise((resolve, reject) => {
      let url = basePath + "/Tag";

      const configs: IRequestConfig = getConfigs(
        "get",
        "application/json",
        url,
        options
      );
      configs.params = { id: params["id"], name: params["name"] };

      axios(configs, resolve, reject);
    });
  }
  /**
   * Find tag by ID
   */
  static getTagById(
    params: {
      /** ID of tag to return */
      tagId: number;
    } = {} as any,
    options: IRequestOptions = {}
  ): Promise<any | null> {
    return new Promise((resolve, reject) => {
      let url = basePath + "/Tag/{tagId}";
      url = url.replace("{tagId}", params["tagId"] + "");

      const configs: IRequestConfig = getConfigs(
        "get",
        "application/json",
        url,
        options
      );

      axios(configs, resolve, reject);
    });
  }
  /**
   * Update tag
   */
  static updateTag(
    params: {
      /** ID of tag you want to update */
      tagId: number;
    } = {} as any,
    options: IRequestOptions = {}
  ): Promise<Model_TagResponse> {
    return new Promise((resolve, reject) => {
      let url = basePath + "/Tag/{tagId}";
      url = url.replace("{tagId}", params["tagId"] + "");

      const configs: IRequestConfig = getConfigs(
        "put",
        "application/json",
        url,
        options
      );

      let data = null;

      configs.data = data;

      axios(configs, resolve, reject);
    });
  }
  /**
   * Deletes a tag
   */
  static deleteTag(
    params: {
      /** Id of tag to delete */
      tagId: number;
    } = {} as any,
    options: IRequestOptions = {}
  ): Promise<any> {
    return new Promise((resolve, reject) => {
      let url = basePath + "/Tag/{tagId}";
      url = url.replace("{tagId}", params["tagId"] + "");

      const configs: IRequestConfig = getConfigs(
        "delete",
        "application/json",
        url,
        options
      );

      let data = null;

      configs.data = data;

      axios(configs, resolve, reject);
    });
  }
  /**
   * Create a new tag
   */
  static createTag(
    options: IRequestOptions = {}
  ): Promise<Model_TagCreateResponse> {
    return new Promise((resolve, reject) => {
      let url = basePath + "/Tag/Factory/create";

      const configs: IRequestConfig = getConfigs(
        "post",
        "application/json",
        url,
        options
      );

      let data = null;

      configs.data = data;

      axios(configs, resolve, reject);
    });
  }
  /**
   * Retrieve tag relations
   */
  static getTagRelations(options: IRequestOptions = {}): Promise<any | null> {
    return new Promise((resolve, reject) => {
      let url = basePath + "/TagRelation";

      const configs: IRequestConfig = getConfigs(
        "get",
        "application/json",
        url,
        options
      );

      axios(configs, resolve, reject);
    });
  }
}

export interface ObjectsWrapper<T> {
  objects: T;
}

export interface ObjectReference {
  id: number,
  objectName: string
}

export interface ResponseObjectReference {
  id: string, // NOTE: deviates from API spec, but is integer in practice
  objectName: string
}

export interface Model_CheckAccountResponse {
  /** The check account id */
  id?: string;

  /** The check account object name */
  objectName?: string;

  /** Date of check account creation */
  create?: Date;

  /** Date of last check account update */
  update?: Date;

  /** Client to which check account belongs. Will be filled automatically */
  sevClient?: object;

  /** Name of the check account */
  name?: string;

  /** The type of the check account. Account with a CSV or MT940 import are regarded as online.<br>
     Apart from that, created check accounts over the API need to be offline, as online accounts with an active connection
     to a bank application can not be managed over the API. */
  type?: EnumModel_CheckAccountResponseType;

  /** Import type. Transactions can be imported by this method on the check account. */
  importType?: EnumModel_CheckAccountResponseImportType;

  /** The currency of the check account. */
  currency?: string;

  /** Defines if this check account is the default account. */
  defaultAccount?: string;

  /** Status of the check account. 0 <-> Archived - 100 <-> Active */
  status?: EnumModel_CheckAccountResponseStatus;

  /** Bank server of check account */
  bankServer?: string;

  /** Defines if transactions on this account are automatically mapped to invoice and vouchers when imported if possible. */
  autoMapTransactions?: string;
}

export interface Model_CheckAccount {
  /** The check account id */
  id?: number;

  /** The check account object name */
  objectName?: string;

  /** Date of check account creation */
  create?: Date;

  /** Date of last check account update */
  update?: Date;

  /** Client to which check account belongs. Will be filled automatically */
  sevClient?: object;

  /** Name of the check account */
  name: string;

  /** The type of the check account. Account with a CSV or MT940 import are regarded as online.<br>
     Apart from that, created check accounts over the API need to be offline, as online accounts with an active connection
     to a bank application can not be managed over the API. */
  type: EnumModel_CheckAccountType;

  /** Import type. Transactions can be imported by this method on the check account. */
  importType?: EnumModel_CheckAccountImportType;

  /** The currency of the check account. */
  currency: string;

  /** Defines if this check account is the default account. */
  defaultAccount?: IModel_CheckAccountDefaultAccount;

  /** Status of the check account. 0 <-> Archived - 100 <-> Active */
  status: IModel_CheckAccountStatus;

  /** Bank server of check account */
  bankServer?: string;

  /** Defines if transactions on this account are automatically mapped to invoice and vouchers when imported if possible. */
  autoMapTransactions?: number;
}

export interface Model_CheckAccountUpdate {
  /** Name of the check account */
  name?: string;

  /** The type of the check account. Account with a CSV or MT940 import are regarded as online.<br>
     Apart from that, created check accounts over the API need to be offline, as online accounts with an active connection
     to a bank application can not be managed over the API. */
  type?: EnumModel_CheckAccountUpdateType;

  /** Import type. Transactions can be imported by this method on the check account. */
  importType?: EnumModel_CheckAccountUpdateImportType;

  /** The currency of the check account. */
  currency?: string;

  /** Defines if this check account is the default account. */
  defaultAccount?: IModel_CheckAccountUpdateDefaultAccount;

  /** Status of the check account. 0 <-> Archived - 100 <-> Active */
  status?: IModel_CheckAccountUpdateStatus;

  /** Defines if transactions on this account are automatically mapped to invoice and vouchers when imported if possible. */
  autoMapTransactions?: number;
}

export interface Model_CheckAccountTransactionResponse {
  /** The check account transaction id */
  id?: string;

  /** The check account transaction object name */
  objectName?: string;

  /** Date of check account transaction creation */
  create?: Date;

  /** Date of last check account transaction update */
  update?: Date;

  /** Client to which check account transaction belongs. Will be filled automatically */
  sevClient?: object;

  /** Date the check account transaction was imported */
  valueDate?: Date;

  /** Date the check account transaction was booked */
  entryDate?: Date;

  /** the purpose of the transaction */
  paymtPurpose?: string;

  /** Amount of the transaction */
  amount?: string;

  /** Name of the payee\/payer */
  payeePayerName?: string;

  /** The check account to which the transaction belongs */
  checkAccount?: object;

  /** Status of the check account transaction.<br>
     100 <-> Created<br>
     200 <-> Linked<br>
     300 <-> Private<br>
     400 <-> Booked */
  status?: EnumModel_CheckAccountTransactionResponseStatus;

  /** Defines if the transaction has been enshrined and can not be changed any more. */
  enshrined?: Date;

  /** The check account transaction serving as the source of the rebooking */
  sourceTransaction?: object;

  /** The check account transaction serving as the target of the rebooking */
  targetTransaction?: object;
}

export interface Model_CheckAccountTransaction {
  /** The check account transaction id */
  id?: number;

  /** The check account transaction object name */
  objectName?: string;

  /** Date of check account transaction creation */
  create?: Date;

  /** Date of last check account transaction update */
  update?: Date;

  /** Client to which check account transaction belongs. Will be filled automatically */
  sevClient?: object;

  /** Date the check account transaction was booked */
  valueDate: Date;

  /** Date the check account transaction was imported */
  entryDate?: Date;

  /** the purpose of the transaction */
  paymtPurpose?: string;

  /** Amount of the transaction */
  amount: number;

  /** Name of the payee\/payer */
  payeePayerName: string;

  /** The check account to which the transaction belongs */
  checkAccount: object;

  /** Status of the check account transaction.<br>
     100 <-> Created<br>
     200 <-> Linked<br>
     300 <-> Private<br>
     400 <-> Booked */
  status: IModel_CheckAccountTransactionStatus;

  /** Defines if the transaction has been enshrined and can not be changed any more. */
  enshrined?: Date;

  /** The check account transaction serving as the source of the rebooking */
  sourceTransaction?: object;

  /** The check account transaction serving as the target of the rebooking */
  targetTransaction?: object;
}

export interface Model_CheckAccountTransactionUpdate {
  /** Date the check account transaction was booked */
  valueDate?: Date;

  /** Date the check account transaction was imported */
  entryDate?: Date;

  /** the purpose of the transaction */
  paymtPurpose?: string;

  /** Amount of the transaction */
  amount?: number;

  /** Name of the payee\/payer */
  payeePayerName?: string;

  /** The check account to which the transaction belongs */
  checkAccount?: object;

  /** Status of the check account transaction.<br>
     100 <-> Created<br>
     200 <-> Linked<br>
     300 <-> Private<br>
     400 <-> Booked */
  status?: IModel_CheckAccountTransactionUpdateStatus;

  /** Defines if the transaction has been enshrined and can not be changed any more. */
  enshrined?: Date;

  /** The check account transaction serving as the source of the rebooking */
  sourceTransaction?: object;

  /** The check account transaction serving as the target of the rebooking */
  targetTransaction?: object;
}

export interface Model_ContactResponse {
  /** The contact id */
  id: string; // NOTE: integer wrapped as string

  /** The contact object name */
  objectName: string;

  /** Date of contact creation */
  create: Date;

  /** Date of last contact update */
  update: Date;

  /** The organization name.<br>
Be aware that the type of contact will depend on this attribute.<br>
If it holds a value, the contact will be regarded as an organization. */
  name?: string;

  /** Defines the status of the contact. 100 <-> Lead - 500 <-> Pending - 1000 <-> Active. */
  status?: string;

  /** The customer number */
  customerNumber?: string;

  /** The parent contact to which this contact belongs. Must be an organization. */
  parent?: ResponseObjectReference;

  /** The <b>first<\/b> name of the contact.<br>
Yeah... not quite right in literally every way. We know.<br>
Not to be used for organizations. */
  surename?: string;

  /** The last name of the contact.<br>
Not to be used for organizations. */
  familyname?: string;

  /** A non-academic title for the contact.
Not to be used for organizations. */
  titel?: string;

  /** Category of the contact.<br> For more information,
     see <a href='https:\/\/my.sevdesk.de\/apiOverview\/index.html#\/doc-contacts#types'>here<\/a>. */
  category: ResponseObjectReference;

  /** A description for the contact. */
  description?: string;

  /** A academic title for the contact.
Not to be used for organizations. */
  academicTitle?: string;

  /** Gender of the contact.<br>
Not to be used for organizations. */
  gender?: string;

  /** Client to which contact belongs. Will be filled automatically */
  sevClient?: object;

  /** Second name of the contact.<br>
Not to be used for organizations. */
  name2?: string;

  /** Birthday of the contact.<br>
Not to be used for organizations. */
  birthday?: Date;

  /** Vat number of the contact. */
  vatNumber?: string;

  /** Bank account number (IBAN) of the contact. */
  bankAccount?: string;

  /** Bank number of the bank used by the contact. */
  bankNumber?: string;

  /** Absolute time in days which the contact has to pay his invoices and subsequently get a cashback. */
  defaultCashbackTime?: string;

  /** Percentage of the invoice sum the contact gets back if he payed invoices in time. */
  defaultCashbackPercent?: string;

  /** The payment goal in days which is set for every invoice of the contact. */
  defaultTimeToPay?: string;

  /** The tax number of the contact. */
  taxNumber?: string;

  /** The tax office of the contact (only for greek customers). */
  taxOffice?: string;

  /** Defines if the contact is freed from paying vat. */
  exemptVat?: string;

  /** Defines which tax regulation the contact is using. */
  taxType?: EnumModel_ContactResponseTaxType;

  /** Tax set which is used in every invoice of the contact. */
  taxSet?: object;

  /** The default discount the contact gets for every invoice.<br>
Depending on defaultDiscountPercentage attribute, in percent or absolute value. */
  defaultDiscountAmount?: string;

  /** Defines if the discount is a percentage (true) or an absolute value (false). */
  defaultDiscountPercentage?: string;

  /** Buyer reference of the contact. */
  buyerReference?: string;

  /** Defines whether the contact is a government agency (true) or not (false). */
  governmentAgency?: string;

  /** Additional information stored for the contact. */
  additionalInformation?: string;
}

export interface Model_Contact {
  /** The organization name.<br>
Be aware that the type of contact will depend on this attribute.<br>
If it holds a value, the contact will be regarded as an organization. */
  name?: string;

  /** Defines the status of the contact. 100 <-> Lead - 500 <-> Pending - 1000 <-> Active. */
  status?: EnumModel_ContactStatus;

  /** The customer number */
  customerNumber?: string;

  /** The parent contact to which this contact belongs. Must be an organization. */
  parent?: ObjectReference;

  /** The <b>first<\/b> name of the contact.<br>
Yeah... not quite right in literally every way. We know.<br>
Not to be used for organizations. */
  surename?: string;

  /** The last name of the contact.<br>
Not to be used for organizations. */
  familyname?: string;

  /** A non-academic title for the contact.
Not to be used for organizations. */
  titel?: string;

  /** Category of the contact.<br> For more information,
     see <a href='https:\/\/my.sevdesk.de\/apiOverview\/index.html#\/doc-contacts#types'>here<\/a>. */
  category: EnumModel_ContactCategory;

  /** A description for the contact. */
  description?: string;

  /** A academic title for the contact.
Not to be used for organizations. */
  academicTitle?: string;

  /** Gender of the contact.<br>
m-male, f-female (both case sensitive) or custom string<br>
Not to be used for organizations.
  */
  gender?: string;

  /** Second name of the contact.<br>
Not to be used for organizations. */
  name2?: string;

  /** Birthday of the contact.<br>
Not to be used for organizations. */
  birthday?: Date;

  /** Vat number of the contact. */
  vatNumber?: string;

  /** Bank account number (IBAN) of the contact. */
  bankAccount?: string;

  /** Bank number of the bank used by the contact. */
  bankNumber?: string;

  /** Absolute time in days which the contact has to pay his invoices and subsequently get a cashback. */
  defaultCashbackTime?: number;

  /** Percentage of the invoice sum the contact gets back if he payed invoices in time. */
  defaultCashbackPercent?: number;

  /** The payment goal in days which is set for every invoice of the contact. */
  defaultTimeToPay?: number;

  /** The tax number of the contact. */
  taxNumber?: string;

  /** The tax office of the contact (only for greek customers). */
  taxOffice?: string;

  /** Defines if the contact is freed from paying vat. */
  exemptVat?: boolean;

  /** Defines which tax regulation the contact is using. */
  taxType?: EnumModel_ContactTaxType;

  /** Tax set which is used in every invoice of the contact. */
  taxSet?: object;

  /** The default discount the contact gets for every invoice.<br>
Depending on defaultDiscountPercentage attribute, in percent or absolute value. */
  defaultDiscountAmount?: number;

  /** Defines if the discount is a percentage (true) or an absolute value (false). */
  defaultDiscountPercentage?: boolean;

  /** Buyer reference of the contact. */
  buyerReference?: string;

  /** Defines whether the contact is a government agency (true) or not (false). */
  governmentAgency?: boolean;
}

export interface Model_ContactUpdate {
  /** The organization name.<br>
Be aware that the type of contact will depend on this attribute.<br>
If it holds a value, the contact will be regarded as an organization. */
  name?: string;

  /** Defines the status of the contact. 100 <-> Lead - 500 <-> Pending - 1000 <-> Active. */
  status?: EnumModel_ContactStatus;

  /** The customer number */
  customerNumber?: string;

  /** The parent contact to which this contact belongs. Must be an organization. */
  parent?: ObjectReference;

  /** The <b>first<\/b> name of the contact.<br>
Yeah... not quite right in literally every way. We know.<br>
Not to be used for organizations. */
  surename?: string;

  /** The last name of the contact.<br>
Not to be used for organizations. */
  familyname?: string;

  /** A non-academic title for the contact.
Not to be used for organizations. */
  titel?: string;

  /** Category of the contact.<br> For more information,
     see <a href='https:\/\/my.sevdesk.de\/apiOverview\/index.html#\/doc-contacts#types'>here<\/a>. */
  category?: EnumModel_ContactCategory;

  /** A description for the contact. */
  description?: string;

  /** A academic title for the contact.
Not to be used for organizations. */
  academicTitle?: string;

  /** Gender of the contact.<br>
Not to be used for organizations. */
  gender?: string;

  /** Second name of the contact.<br>
Not to be used for organizations. */
  name2?: string;

  /** Birthday of the contact.<br>
Not to be used for organizations. */
  birthday?: Date;

  /** Vat number of the contact. */
  vatNumber?: string;

  /** Bank account number (IBAN) of the contact. */
  bankAccount?: string;

  /** Bank number of the bank used by the contact. */
  bankNumber?: string;

  /** Absolute time in days which the contact has to pay his invoices and subsequently get a cashback. */
  defaultCashbackTime?: number;

  /** Percentage of the invoice sum the contact gets back if he payed invoices in time. */
  defaultCashbackPercent?: number;

  /** The payment goal in days which is set for every invoice of the contact. */
  defaultTimeToPay?: number;

  /** The tax number of the contact. */
  taxNumber?: string;

  /** The tax office of the contact (only for greek customers). */
  taxOffice?: string;

  /** Defines if the contact is freed from paying vat. */
  exemptVat?: boolean;

  /** Defines which tax regulation the contact is using. */
  taxType?: EnumModel_ContactUpdateTaxType;

  /** Tax set which is used in every invoice of the contact. */
  taxSet?: object;

  /** The default discount the contact gets for every invoice.<br>
Depending on defaultDiscountPercentage attribute, in percent or absolute value. */
  defaultDiscountAmount?: number;

  /** Defines if the discount is a percentage (true) or an absolute value (false). */
  defaultDiscountPercentage?: boolean;

  /** Buyer reference of the contact. */
  buyerReference?: string;

  /** Defines whether the contact is a government agency (true) or not (false). */
  governmentAgency?: boolean;
}

export interface Model_ContactAddressResponse {
  /** The contact address id */
  id: string; // NOTE: integer wrapped as string

  /** The contact address object name */
  objectName: string;

  /** Date of contact address creation */
  create: Date;

  /** Date of last contact address update */
  update: Date;

  /** The contact to which this contact address belongs. */
  contact: ResponseObjectReference;

  /** Street name */
  street?: string;

  /** Zib code */
  zip?: string;

  /** City name */
  city?: string;

  /** Country of the contact address.<br>
    For all countries, send a GET to \/StaticCountry */
  country: ResponseObjectReference;

  /** Category of the contact address.<br>
     For all categories, send a GET to \/Category?objectType=ContactAddress. */
  category?: ResponseObjectReference;

  /** Name in address */
  name?: string;

  /** Client to which contact address belongs. Will be filled automatically */
  sevClient?: object;

  /** Second name in address */
  name2?: string;

  /** Third name in address */
  name3?: string;

  /** Fourth name in address */
  name4?: string;
}

export interface Model_ContactAddress {
  /** The contact to which this contact address belongs. */
  contact: ObjectReference;

  /** Street name */
  street?: string;

  /** Zib code */
  zip?: string;

  /** City name */
  city?: string;

  /** Country of the contact address.<br>
    For all countries, send a GET to \/StaticCountry */
  country: ObjectReference;

  /** Category of the contact address.<br>
     For all categories, send a GET to \/Category?objectType=ContactAddress. */
  category?: ObjectReference;

  /** Name in address */
  name?: string;

  /** Second name in address */
  name2?: string;

  /** Third name in address */
  name3?: string;

  /** Fourth name in address */
  name4?: string;
}

export interface Model_ContactAddressUpdate {
  /** The contact to which this contact address belongs. */
  contact?: ObjectReference;

  /** Street name */
  street?: string;

  /** Zib code */
  zip?: string;

  /** City name */
  city?: string;

  /** Country of the contact address.<br>
    For all countries, send a GET to \/StaticCountry */
  country?: ObjectReference;

  /** Category of the contact address.<br>
     For all categories, send a GET to \/Category?objectType=ContactAddress. */
  category?: ObjectReference;

  /** Name in address */
  name?: string;

  /** Second name in address */
  name2?: string;

  /** Third name in address */
  name3?: string;

  /** Fourth name in address */
  name4?: string;
}

export interface Model_CommunicationWayResponse {
  /** The communication way id */
  id: string; // NOTE: integer wrapped as string

  /** The communication way object name */
  objectName: string;

  /** Date of communication way creation */
  create: Date;

  /** Date of last communication way update */
  update: Date;

  /** The contact to which this communication way belongs. */
  contact?: ResponseObjectReference;

  /** Type of the communication way */
  type: EnumModel_CommunicationWayResponseType;

  /** The value of the communication way.<br>
     For example the phone number, e-mail address or website. */
  value: string;

  /** The key of the communication way.<br>
Similar to the category of addresses.<br>
For all communication way keys please send a GET to \/CommunicationWayKey. */
  key: ResponseObjectReference;

  /** Defines whether the communication way is the main communication way for the contact. */
  main?: string;

  /** Client to which communication way key belongs. Will be filled automatically */
  sevClient?: object;
}

export interface Model_CommunicationWay {
  /** The contact to which this communication way belongs. */
  contact?: ObjectReference;

  /** Type of the communication way */
  type: EnumModel_CommunicationWayType;

  /** The value of the communication way.<br>
     For example the phone number, e-mail address or website. */
  value: string;

  /** The key of the communication way.<br>
Similar to the category of addresses.<br>
For all communication way keys please send a GET to \/CommunicationWayKey. */
  key: ObjectReference;

  /** Defines whether the communication way is the main communication way for the contact. */
  main?: boolean;
}

export interface Model_CommunicationWayUpdate {
  /** The contact to which this communication way belongs. */
  contact?: ObjectReference;

  /** Type of the communication way */
  type?: EnumModel_CommunicationWayUpdateType;

  /** The value of the communication way.<br>
     For example the phone number, e-mail address or website. */
  value?: string;

  /** The key of the communication way.<br>
Similar to the category of addresses.<br>
For all communication way keys please send a GET to \/CommunicationWayKey. */
  key?: ObjectReference;

  /** Defines whether the communication way is the main communication way for the contact. */
  main?: boolean;
}

export interface Model_AccountingContactResponse {
  /** The accounting contact id */
  id?: string;

  /** The accounting contact object name */
  objectName?: string;

  /** Date of accounting contact creation */
  create?: Date;

  /** Date of last accounting contact update */
  update?: Date;

  /** The contact to which this accounting contact belongs. */
  contact?: object;

  /** Client to which accounting contact belongs. Will be filled automatically */
  sevClient?: object;

  /** Debitor number of the accounting contact. */
  debitorNumber?: string;

  /** Creditor number of the accounting contact. */
  creditorNumber?: string;
}

export interface Model_AccountingContact {
  /** The contact to which this accounting contact belongs. */
  contact: object;

  /** Debitor number of the accounting contact. */
  debitorNumber?: number;

  /** Creditor number of the accounting contact. */
  creditorNumber?: number;
}

export interface Model_AccountingContactUpdate {
  /** The contact to which this accounting contact belongs. */
  contact?: object;

  /** Debitor number of the accounting contact. */
  debitorNumber?: number;

  /** Creditor number of the accounting contact. */
  creditorNumber?: number;
}

export interface Model_Textparser_fetchDictionaryEntriesByType_response {
  /**  */
  key?: string;

  /**  */
  value?: any | null[];
}

export interface Model_ContactCustomFieldSettingResponse {
  /** Id of the contact field */
  id?: string;

  /** Internal object name which is 'ContactCustomFieldSetting'. */
  objectName?: string;

  /** Date of contact field creation */
  create?: Date;

  /** Date of contact field updated */
  update?: Date;

  /** Client to which invoice belongs. Will be filled automatically */
  sevClient?: object;

  /** name of the contact fields */
  name?: string;

  /** Unique identifier for the contact field */
  identifier?: string;

  /** The description of the contact field */
  description?: string;
}

export interface Model_ContactCustomFieldResponse {
  /** id of the contact field */
  id?: string;

  /** Internal object name which is 'ContactCustomField'. */
  objectName?: string;

  /** Date of contact field creation */
  create?: Date;

  /** Date of contact field update */
  update?: Date;

  /** Client to which contact field belongs. Will be filled automatically */
  sevClient?: object;

  /** name of the contact */
  contact?: object;

  /** the contact custom field setting */
  contactCustomFieldSetting?: CombinedContactCustomFieldSettingTypes;

  /** The value of the contact field */
  value?: string;
}

export interface Model_ContactCustomField {
  /** name of the contact */
  contact: object;

  /** name of the contact custom field setting */
  contactCustomFieldSetting: object;

  /** The value of the contact field */
  value: string;

  /** Internal object name which is 'ContactCustomField'. */
  objectName: string;
}

export interface Model_ContactCustomFieldUpdate {
  /** name of the contact */
  contact?: object;

  /** name of the contact custom field setting */
  contactCustomFieldSetting?: object;

  /** The value of the contact field */
  value?: string;

  /** Internal object name which is 'ContactCustomField'. */
  objectName?: string;
}

export interface Model_ContactCustomFieldSetting {
  /** name of the contact fields */
  name: string;

  /** The description of the contact field */
  description?: string;

  /** Internal object name which is 'ContactCustomFieldSetting'. */
  objectName?: string;
}

export interface Model_ContactCustomFieldSettingUpdate {
  /** name of the contact fields */
  name?: string;

  /** The description of the contact field */
  description?: string;

  /** Internal object name which is 'ContactCustomFieldSetting'. */
  objectName?: string;
}

export interface Model_creditNoteResponse {
  /** The creditNote id */
  id?: string;

  /** The creditNote object name */
  objectName?: string;

  /** Date of creditNote creation */
  create?: Date;

  /** Date of last creditNote update */
  update?: Date;

  /** The creditNote number */
  creditNoteNumber?: string;

  /** The contact used in the creditNote */
  contact?: object;

  /** Needs to be provided as timestamp or dd.mm.yyyy */
  creditNoteDate?: Date;

  /** Please have a look in 
    <a href='https:\/\/api.sevdesk.de\/#section\/Types-and-status-of-credit-notes'>status of credit note<\/a>
    to see what the different status codes mean */
  status?: EnumModel_creditNoteResponseStatus;

  /** Normally consist of prefix plus the creditNote number */
  header?: string;

  /** Certain html tags can be used here to format your text */
  headText?: string;

  /** Certain html tags can be used here to format your text */
  footText?: string;

  /** Can be omitted as complete address is defined in address attribute */
  addressCountry?: object;

  /** Will be filled automatically by our system and can't be changed */
  createUser?: object;

  /** Client to which creditNote belongs. Will be filled automatically */
  sevClient?: object;

  /** Delivery terms of the creditNote */
  deliveryTerms?: string;

  /** Timestamp. This can also be a date range if you also use the attribute deliveryDateUntil */
  deliveryDate?: Date;

  /** Payment terms of the creditNote */
  paymentTerms?: string;

  /** Version of the creditNote.<br>
    Can be used if you have multiple drafts for the same creditNote.<br>
    Should start with 0 */
  version?: string;

  /** Defines if the client uses the small settlement scheme.
    If yes, the creditNote must not contain any vat */
  smallSettlement?: boolean;

  /** The user who acts as a contact person for the creditNote */
  contactPerson?: object;

  /** Is overwritten by creditNote position tax rates */
  taxRate?: string;

  /** Tax set of the creditNote. Needs to be added if you chose the tax type custom */
  taxSet?: object;

  /** A common tax text would be 'Umsatzsteuer 19%' */
  taxText?: string;

  /** Tax type of the creditNote.
There are four tax types:
1. default - Umsatzsteuer ausweisen
2. eu - Steuerfreie innergemeinschaftliche Lieferung (Europäische Union)
3. noteu - Steuerschuldnerschaft des Leistungsempfängers (außerhalb EU, z. B. Schweiz)
4. custom - Using custom tax set
5. ss - Not subject to VAT according to §19 1 UStG
Tax rates are heavily connected to the tax type used. */
  taxType?: string;

  /** The date the creditNote was sent to the customer */
  sendDate?: Date;

  /** Complete address of the recipient including name, street, city, zip and country.<br>
     Line breaks can be used and will be displayed on the invoice pdf. */
  address?: string;

  /** Currency used in the creditNote. Needs to be currency code according to ISO-4217 */
  currency?: string;

  /** Net sum of the creditNote */
  sumNet?: string;

  /** Tax sum of the creditNote */
  sumTax?: string;

  /** Gross sum of the creditNote */
  sumGross?: string;

  /** Sum of all discounts in the creditNote */
  sumDiscounts?: string;

  /** Net sum of the creditNote in the foreign currency */
  sumNetForeignCurrency?: string;

  /** Tax sum of the creditNote in the foreign currency */
  sumTaxForeignCurrency?: string;

  /** Gross sum of the creditNote in the foreign currency */
  sumGrossForeignCurrency?: string;

  /** Discounts sum of the creditNote in the foreign currency */
  sumDiscountsForeignCurrency?: string;

  /** Internal note of the customer. Contains data entered into field 'Referenz\/Bestellnummer' */
  customerInternalNote?: string;

  /** If true, the net amount of each position will be shown on the creditNote. Otherwise gross amount */
  showNet?: boolean;

  /** Type which was used to send the creditNote. IMPORTANT: Please refer to the creditNote section of the
   *     API-Overview to understand how this attribute can be used before using it! */
  sendType?: EnumModel_creditNoteResponseSendType;
}

export interface Model_creditNote {
  /** The creditNote id. <span style='color:red'>Required<\/span> if you want to create\/update an credit note position for an existing credit note" */
  id?: number;

  /** The creditNote object name */
  objectName: string;

  /**  */
  mapAll: boolean;

  /** Date of creditNote creation */
  create?: Date;

  /** Date of last creditNote update */
  update?: Date;

  /** The creditNote number */
  creditNoteNumber: string;

  /** The contact used in the creditNote */
  contact: object;

  /** Needs to be provided as timestamp or dd.mm.yyyy */
  creditNoteDate: Date;

  /** Please have a look in 
    <a href='https:\/\/api.sevdesk.de\/#section\/Types-and-status-of-credit-notes'>status of credit note<\/a>
    to see what the different status codes mean */
  status: EnumModel_creditNoteStatus;

  /** Normally consist of prefix plus the creditNote number */
  header: string;

  /** Certain html tags can be used here to format your text */
  headText?: string;

  /** Certain html tags can be used here to format your text */
  footText?: string;

  /** Can be omitted as complete address is defined in address attribute */
  addressCountry: object;

  /** Will be filled automatically by our system and can't be changed */
  createUser?: object;

  /** Client to which creditNote belongs. Will be filled automatically */
  sevClient?: object;

  /** Delivery terms of the creditNote */
  deliveryTerms?: string;

  /** Payment terms of the creditNote */
  paymentTerms?: string;

  /** Version of the creditNote.<br>
    Can be used if you have multiple drafts for the same creditNote.<br>
    Should start with 0 */
  version?: number;

  /** Defines if the client uses the small settlement scheme.
    If yes, the creditNote must not contain any vat */
  smallSettlement?: boolean;

  /** The user who acts as a contact person for the creditNote */
  contactPerson: object;

  /** Is overwritten by creditNote position tax rates */
  taxRate: number;

  /** Tax set of the creditNote. Needs to be added if you chose the tax type custom */
  taxSet?: object;

  /** A common tax text would be 'Umsatzsteuer 19%' */
  taxText: string;

  /** Tax type of the creditNote.
There are four tax types:
1. default - Umsatzsteuer ausweisen
2. eu - Steuerfreie innergemeinschaftliche Lieferung (Europäische Union)
3. noteu - Steuerschuldnerschaft des Leistungsempfängers (außerhalb EU, z. B. Schweiz)
4. custom - Using custom tax set
5. ss - Not subject to VAT according to §19 1 UStG
Tax rates are heavily connected to the tax type used. */
  taxType: string;

  /** The date the creditNote was sent to the customer */
  sendDate?: Date;

  /** Complete address of the recipient including name, street, city, zip and country.<br>
     Line breaks can be used and will be displayed on the invoice pdf. */
  address?: string;

  /** defines the booking category, for more information see the section "<a href='https:\/\/api.sevdesk.de\/#section\/Credit-note-booking-categories'>Credit note booking categories<\/a>" */
  bookingCategory: EnumModel_creditNoteBookingCategory;

  /** Currency used in the creditNote. Needs to be currency code according to ISO-4217 */
  currency: string;

  /** Net sum of the creditNote */
  sumNet?: number;

  /** Tax sum of the creditNote */
  sumTax?: number;

  /** Gross sum of the creditNote */
  sumGross?: number;

  /** Sum of all discounts in the creditNote */
  sumDiscounts?: number;

  /** Net sum of the creditNote in the foreign currency */
  sumNetForeignCurrency?: number;

  /** Tax sum of the creditNote in the foreign currency */
  sumTaxForeignCurrency?: number;

  /** Gross sum of the creditNote in the foreign currency */
  sumGrossForeignCurrency?: number;

  /** Discounts sum of the creditNote in the foreign currency */
  sumDiscountsForeignCurrency?: number;

  /** Internal note of the customer. Contains data entered into field 'Referenz\/Bestellnummer' */
  customerInternalNote?: string;

  /** If true, the net amount of each position will be shown on the creditNote. Otherwise gross amount */
  showNet?: boolean;

  /** Type which was used to send the creditNote. IMPORTANT: Please refer to the creditNote section of the
   *     API-Overview to understand how this attribute can be used before using it! */
  sendType?: EnumModel_creditNoteSendType;
}

export interface Model_creditNotePos {
  /** The creditNote position id. */
  id?: number;

  /** The creditNote position object name */
  objectName: string;

  /**  */
  mapAll: boolean;

  /** Date of creditNote position creation */
  create?: string;

  /** Date of last creditNote position update */
  update?: string;

  /** The creditNote to which the position belongs.  <span style='color:red'>Required<\/span> if you want to create\/update an credit note position for an existing credit note" */
  creditNote?: object;

  /** Part from your inventory which is used in the position. */
  part?: object;

  /** Quantity of the article\/part */
  quantity: number;

  /** Price of the article\/part. Is either gross or net, depending on the sevDesk account setting. */
  price?: number;

  /** Net price of the part */
  priceNet?: number;

  /** Tax on the price of the part */
  priceTax?: number;

  /** Gross price of the part */
  priceGross?: number;

  /** Name of the article\/part. */
  name?: string;

  /** The unit in which the positions part is measured */
  unity: object;

  /** Client to which creditNote position belongs. Will be filled automatically */
  sevClient?: object;

  /** Position number of your position. Can be used to creditNote multiple positions. */
  positionNumber?: number;

  /** A text describing your position. */
  text?: string;

  /** An optional discount of the position. */
  discount?: number;

  /** Defines if the position is optional. */
  optional?: boolean;

  /** Tax rate of the position. */
  taxRate: number;

  /** Discount sum of the position */
  sumDiscount?: number;
}

export interface saveCreditNote {
  /**  */
  creditNote: Model_creditNote;

  /**  */
  creditNotePosSave?: Model_creditNotePos[];

  /**  */
  creditNotePosDelete?: any | null;

  /** Filename of a previously upload file which should be attached. */
  filename?: string;

  /**  */
  discountSave?: any | null;

  /**  */
  discountDelete?: any | null;
}

export interface Model_creditNotePosResponse {
  /** The creditNote position id */
  id?: string;

  /** The creditNote position object name */
  objectName?: string;

  /** Date of creditNote position creation */
  create?: string;

  /** Date of last creditNote position update */
  update?: string;

  /** The creditNote to which the position belongs. */
  creditNote: object;

  /** Part from your inventory which is used in the position. */
  part?: object;

  /** Quantity of the article\/part */
  quantity: string;

  /** Price of the article\/part. Is either gross or net, depending on the sevDesk account setting. */
  price?: string;

  /** Net price of the part */
  priceNet?: string;

  /** Tax on the price of the part */
  priceTax?: string;

  /** Gross price of the part */
  priceGross?: string;

  /** Name of the article\/part. */
  name?: string;

  /** The unit in which the positions part is measured */
  unity: object;

  /** Client to which creditNote position belongs. Will be filled automatically */
  sevClient?: object;

  /** Position number of your position. Can be used to creditNote multiple positions. */
  positionNumber?: string;

  /** A text describing your position. */
  text?: string;

  /** An optional discount of the position. */
  discount?: string;

  /** Defines if the position is optional. */
  optional?: boolean;

  /** Tax rate of the position. */
  taxRate: string;

  /** Discount sum of the position */
  sumDiscount?: string;
}

export interface saveCreditNoteResponse {
  /**  */
  voucher?: Model_creditNoteResponse;

  /**  */
  voucherPos?: Model_creditNotePosResponse[];

  /** Filename of a previously upload file which should be attached. */
  filename?: string;
}

export interface Model_discountsResponse {
  /** The id of the discount */
  id?: number;

  /** Model name, which is 'Discounts' */
  objectName?: string;

  /** Date of discount creation */
  create?: string;

  /** Date of last discount update */
  update?: string;

  /** Client to which the discount belongs */
  sevClient?: string;

  /** Indicates that this is a discount or a surcharge (0 = surcharge, 1 = discount) */
  discount?: string;

  /** A text describing your position. */
  text?: string;

  /** Defines if this is a percentage or an absolute discount */
  percentage?: string;

  /** Value of the discount */
  value?: string;

  /** Defines is the Discount net or gross (0 = net, 1 = gross) */
  isNet?: string;
}

export interface Model_creditNoteUpdate {
  /** The creditNote id */
  id?: number;

  /** The creditNote object name */
  objectName?: string;

  /** Date of creditNote creation */
  create?: Date;

  /** Date of last creditNote update */
  update?: Date;

  /** The creditNote number */
  creditNoteNumber?: string;

  /** The contact used in the creditNote */
  contact?: object;

  /** Needs to be provided as timestamp or dd.mm.yyyy */
  creditNoteDate?: Date;

  /** Please have a look in 
    <a href='https:\/\/api.sevdesk.de\/#section\/Types-and-status-of-credit-notes'>status of credit note<\/a>
    to see what the different status codes mean */
  status?: EnumModel_creditNoteUpdateStatus;

  /** Normally consist of prefix plus the creditNote number */
  header?: string;

  /** Certain html tags can be used here to format your text */
  headText?: string;

  /** Certain html tags can be used here to format your text */
  footText?: string;

  /** Can be omitted as complete address is defined in address attribute */
  addressCountry?: object;

  /** Will be filled automatically by our system and can't be changed */
  createUser?: object;

  /** Client to which creditNote belongs. Will be filled automatically */
  sevClient?: object;

  /** Delivery terms of the creditNote */
  deliveryTerms?: string;

  /** Timestamp. This can also be a date range if you also use the attribute deliveryDateUntil */
  deliveryDate?: Date;

  /** Payment terms of the creditNote */
  paymentTerms?: string;

  /** Version of the creditNote.<br>
    Can be used if you have multiple drafts for the same creditNote.<br>
    Should start with 0 */
  version?: number;

  /** Defines if the client uses the small settlement scheme.
    If yes, the creditNote must not contain any vat */
  smallSettlement?: boolean;

  /** The user who acts as a contact person for the creditNote */
  contactPerson?: object;

  /** Is overwritten by creditNote position tax rates */
  taxRate?: number;

  /** Tax set of the creditNote. Needs to be added if you chose the tax type custom */
  taxSet?: object;

  /** A common tax text would be 'Umsatzsteuer 19%' */
  taxText?: string;

  /** Tax type of the creditNote.
There are four tax types:
1. default - Umsatzsteuer ausweisen
2. eu - Steuerfreie innergemeinschaftliche Lieferung (Europäische Union)
3. noteu - Steuerschuldnerschaft des Leistungsempfängers (außerhalb EU, z. B. Schweiz)
4. custom - Using custom tax set
5. ss - Not subject to VAT according to §19 1 UStG
Tax rates are heavily connected to the tax type used. */
  taxType?: string;

  /** The date the creditNote was sent to the customer */
  sendDate?: Date;

  /** Complete address of the recipient including name, street, city, zip and country.<br>
     Line breaks can be used and will be displayed on the invoice pdf. */
  address?: string;

  /** Currency used in the creditNote. Needs to be currency code according to ISO-4217 */
  currency?: string;

  /** Net sum of the creditNote */
  sumNet?: number;

  /** Tax sum of the creditNote */
  sumTax?: number;

  /** Gross sum of the creditNote */
  sumGross?: number;

  /** Sum of all discounts in the creditNote */
  sumDiscounts?: number;

  /** Net sum of the creditNote in the foreign currency */
  sumNetForeignCurrency?: number;

  /** Tax sum of the creditNote in the foreign currency */
  sumTaxForeignCurrency?: number;

  /** Gross sum of the creditNote in the foreign currency */
  sumGrossForeignCurrency?: number;

  /** Discounts sum of the creditNote in the foreign currency */
  sumDiscountsForeignCurrency?: number;

  /** Internal note of the customer. Contains data entered into field 'Referenz\/Bestellnummer' */
  customerInternalNote?: string;

  /** If true, the net amount of each position will be shown on the creditNote. Otherwise gross amount */
  showNet?: boolean;

  /** Type which was used to send the creditNote. IMPORTANT: Please refer to the creditNote section of the
   *     API-Overview to understand how this attribute can be used before using it! */
  sendType?: EnumModel_creditNoteUpdateSendType;
}

export interface Model_CreditNote_sendByWithRender {
  /**  */
  thumbs?: any | null[];

  /**  */
  pages?: number;

  /**  */
  docId?: string;

  /**  */
  parameters?: any | null[];
}

export interface Model_creditNote_mailResponse {
  /**  */
  id?: number;

  /**  */
  objectName?: string;

  /**  */
  additionalInformation?: string;

  /** Date of email creation */
  create?: Date;

  /** Date of last email update */
  update?: Date;

  /**  */
  object?: Model_creditNoteResponse;

  /**  */
  from?: string;

  /**  */
  to?: string;

  /**  */
  subject?: string;

  /**  */
  text?: string;

  /** Client to which creditNote belongs. Will be filled automatically */
  sevClient?: any | null;
}

export interface Model_Part {
  /** The part id */
  id?: number;

  /** The part object name */
  objectName?: string;

  /** Date of part creation */
  create?: Date;

  /** Date of last part update */
  update?: Date;

  /** Name of the part */
  name: string;

  /** The part number */
  partNumber: string;

  /** A text describing the part */
  text?: string;

  /** Category of the part.<br>
    For all categories, send a GET to \/Category?objectType=Part */
  category?: object;

  /** The stock of the part */
  stock: number;

  /** Defines if the stock should be enabled */
  stockEnabled?: boolean;

  /** The unit in which the part is measured */
  unity: object;

  /** Net price for which the part is sold. we will change this parameter so that the gross  price is calculated automatically, until then the priceGross parameter must be used. */
  price?: number;

  /** Net price for which the part is sold */
  priceNet?: number;

  /** Gross price for which the part is sold */
  priceGross?: number;

  /** Client to which part belongs. Will be filled automatically */
  sevClient?: object;

  /** Purchase price of the part */
  pricePurchase?: number;

  /** Tax rate of the part */
  taxRate: number;

  /** Status of the part. 50 <-> Inactive - 100 <-> Active */
  status?: IModel_PartStatus;

  /** An internal comment for the part.<br>
     Does not appear on invoices and orders. */
  internalComment?: string;
}

export interface Model_PartUpdate {
  /** The part id */
  id?: number;

  /** The part object name */
  objectName?: string;

  /** Date of part creation */
  create?: Date;

  /** Date of last part update */
  update?: Date;

  /** Name of the part */
  name?: string;

  /** The part number */
  partNumber?: string;

  /** A text describing the part */
  text?: string;

  /** Category of the part.<br>
    For all categories, send a GET to \/Category?objectType=Part */
  category?: object;

  /** The stock of the part */
  stock?: number;

  /** Defines if the stock should be enabled */
  stockEnabled?: boolean;

  /** The unit in which the part is measured */
  unity?: object;

  /** Net price for which the part is sold. we will change this parameter so that the gross  price is calculated automatically, until then the priceGross parameter must be used. */
  price?: number;

  /** Net price for which the part is sold */
  priceNet?: number;

  /** Gross price for which the part is sold */
  priceGross?: number;

  /** Client to which part belongs. Will be filled automatically */
  sevClient?: object;

  /** Purchase price of the part */
  pricePurchase?: number;

  /** Tax rate of the part */
  taxRate?: number;

  /** Status of the part. 50 <-> Inactive - 100 <-> Active */
  status?: IModel_PartUpdateStatus;

  /** An internal comment for the part.<br>
     Does not appear on invoices and orders. */
  internalComment?: string;
}

export interface Model_InvoiceResponse {
  /** The invoice id */
  id: string;

  /** The invoice object name */
  objectName: string;

  /** The invoice number */
  invoiceNumber?: string;

  /** The contact used in the invoice */
  contact: ResponseObjectReference;

  /** Date of invoice creation */
  create: Date;

  /** Date of last invoice update */
  update: Date;

  /** Client to which invoice belongs. Will be filled automatically */
  sevClient?: object;

  /** Needs to be provided as timestamp or dd.mm.yyyy

**Requirements:**
* For final invoices (invoiceType = 'ER'), the invoiceDate must be later than or equal to the invoiceDate of related advance (invoiceType = 'AR') \/ partial (invoiceType = 'TR') invoices.<\/li> */
  invoiceDate?: string;

  /** Normally consist of prefix plus the invoice number */
  header?: string;

  /** Certain html tags can be used here to format your text */
  headText?: string;

  /** Certain html tags can be used here to format your text */
  footText?: string;

  /** The time the customer has to pay the invoice in days */
  timeToPay?: string;

  /** If a value other than zero is used for the discount attribute,
    you need to specify the amount of days for which the discount is granted. */
  discountTime?: string;

  /** If you want to give a discount, define the percentage here. Otherwise provide zero as value */
  discount?: string;

  /** Can be omitted as complete address is defined in address attribute */
  addressCountry?: ResponseObjectReference;

  /** Needs to be timestamp or dd.mm.yyyy */
  payDate?: Date;

  /** Will be filled automatically by our system and can't be changed */
  createUser?: object;

  /** Timestamp. This can also be a date range if you also use the attribute deliveryDateUntil */
  deliveryDate?: Date;

  /** Please have a look in our
     <a href='https:\/\/api.sevdesk.de\/#section\/Types-and-status-of-invoices'>Types and status of invoices<\/a>
     to see what the different status codes mean */
  status?: EnumModel_InvoiceResponseStatus;

  /** Defines if the client uses the small settlement scheme.
    If yes, the invoice must not contain any vat */
  smallSettlement?: boolean;

  /** The user who acts as a contact person for the invoice */
  contactPerson?: ResponseObjectReference;

  /** Is overwritten by invoice position tax rates */
  taxRate?: string;

  /** A common tax text would be 'Umsatzsteuer 19%' */
  taxText?: string;

  /** Defines how many reminders have already been sent for the invoice.
    Starts with 1 (Payment reminder) and should be incremented by one every time another reminder is sent. */
  dunningLevel?: string;

  /** Tax type of the invoice.
There are four tax types:
1. default - Umsatzsteuer ausweisen
2. eu - Steuerfreie innergemeinschaftliche Lieferung (Europäische Union)
3. noteu - Steuerschuldnerschaft des Leistungsempfängers (außerhalb EU, z. B. Schweiz)
4. custom - Using custom tax set
5. ss - Not subject to VAT according to §19 1 UStG
Tax rates are heavily connected to the tax type used. */
  taxType?: EnumModel_InvoiceResponseTaxType;

  /** Payment method used for the invoice */
  paymentMethod?: ResponseObjectReference;

  /** Cost centre for the invoice */
  costCentre?: object;

  /** The date the invoice was sent to the customer */
  sendDate?: Date;

  /** Origin of the invoice. Could f.e. be an order */
  origin?: object;

  /** Type of the invoice. For more information on the different types, check
     <a href='https:\/\/api.sevdesk.de\/#section\/Types-and-status-of-invoices'>this<\/a> section
 */
  invoiceType?: EnumModel_InvoiceResponseInvoiceType;

  /** The interval in which recurring invoices are due as ISO-8601 duration.<br>
     Necessary attribute for all recurring invoices. */
  accountIntervall?: string;

  /** Timestamp when the next invoice will be generated by this recurring invoice. */
  accountNextInvoice?: string;

  /** Total reminder amount */
  reminderTotal?: string;

  /** Debit of the reminder */
  reminderDebit?: string;

  /** Deadline of the reminder as timestamp */
  reminderDeadline?: Date;

  /** The additional reminder charge */
  reminderCharge?: string;

  /** Tax set of the invoice. Needs to be added if you chose the tax type custom */
  taxSet?: object;

  /** Complete address of the recipient including name, street, city, zip and country.
   * Line breaks can be used and will be displayed on the invoice pdf. */
  address?: string;

  /** Currency used in the invoice. Needs to be currency code according to ISO-4217 */
  currency?: string;

  /** Net sum of the invoice */
  sumNet?: string;

  /** Tax sum of the invoice */
  sumTax?: string;

  /** Gross sum of the invoice */
  sumGross?: string;

  /** Sum of all discounts in the invoice */
  sumDiscounts?: string;

  /** Net sum of the invoice in the foreign currency */
  sumNetForeignCurrency?: string;

  /** Tax sum of the invoice in the foreign currency */
  sumTaxForeignCurrency?: string;

  /** Gross sum of the invoice in the foreign currency */
  sumGrossForeignCurrency?: string;

  /** Discounts sum of the invoice in the foreign currency */
  sumDiscountsForeignCurrency?: string;

  /** Net accounting sum of the invoice. Is usually the same as sumNet */
  sumNetAccounting?: string;

  /** Tax accounting sum of the invoice. Is usually the same as sumTax */
  sumTaxAccounting?: string;

  /** Gross accounting sum of the invoice. Is usually the same as sumGross */
  sumGrossAccounting?: string;

  /** Amount which has already been paid for this invoice by the customer */
  paidAmount?: number;

  /** Internal note of the customer. Contains data entered into field 'Referenz\/Bestellnummer' */
  customerInternalNote?: string;

  /** If true, the net amount of each position will be shown on the invoice. Otherwise gross amount */
  showNet?: boolean;

  /** Defines if and when invoice was enshrined. Enshrined invoices can not be manipulated. */
  enshrined?: Date;

  /** Type which was used to send the invoice. IMPORTANT: Please refer to the invoice section of the
   *     API-Overview to understand how this attribute can be used before using it! */
  sendType?: EnumModel_InvoiceResponseSendType;

  /** If the delivery date should be a time range, another timestamp can be provided in this attribute
   * to define a range from timestamp used in deliveryDate attribute to the timestamp used here. */
  deliveryDateUntil?: string;

  /** Internal attribute */
  datevConnectOnline?: object;

  /** Internal attribute */
  sendPaymentReceivedNotificationDate?: string;
}

export interface Model_Invoice {
  /** The invoice id. <span style='color:red'>Required<\/span> if you want to create or update an invoice position for an existing invoice */
  id?: number;

  /** The invoice object name. */
  objectName: string;

  /** The invoice number */
  invoiceNumber?: string;

  /** The contact used in the invoice */
  contact: ObjectReference;

  /** The user who acts as a contact person for the invoice */
  contactPerson: ObjectReference;

  /** Date of invoice creation */
  create?: Date;

  /** Date of last invoice update */
  update?: Date;

  /** Client to which invoice belongs. Will be filled automatically */
  sevClient?: object;

  /** Needs to be provided as timestamp or dd.mm.yyyy

**Requirements:**
* For final invoices (invoiceType = 'ER'), the invoiceDate must be later than or equal to the invoiceDate of related advance (invoiceType = 'AR') \/ partial (invoiceType = 'TR') invoices.<\/li> */
  invoiceDate: string;

  /** Normally consist of prefix plus the invoice number */
  header?: string;

  /** Certain html tags can be used here to format your text */
  headText?: string;

  /** Certain html tags can be used here to format your text */
  footText?: string;

  /** The time the customer has to pay the invoice in days */
  timeToPay?: number;

  /** If you want to give a discount, define the percentage here. Otherwise provide zero as value */
  discount: number;

  /** Complete address of the recipient including name, street, city, zip and country.
   * Line breaks can be used and will be displayed on the invoice pdf. */
  address?: string;

  /** Can be omitted as complete address is defined in address attribute */
  addressCountry: ObjectReference;

  /** Needs to be timestamp or dd.mm.yyyy */
  payDate?: Date;

  /** Will be filled automatically by our system and can't be changed */
  createUser?: object;

  /** Timestamp. This can also be a date range if you also use the attribute deliveryDateUntil */
  deliveryDate?: Date;

  /** If the delivery date should be a time range, another timestamp can be provided in this attribute
   * to define a range from timestamp used in deliveryDate attribute to the timestamp used here. */
  deliveryDateUntil?: number;

  /** Please have a look in our
     <a href='https:\/\/api.sevdesk.de\/#section\/Types-and-status-of-invoices'>Types and status of invoices<\/a>
     to see what the different status codes mean */
  status: EnumModel_InvoiceStatus;

  /** Defines if the client uses the small settlement scheme.
    If yes, the invoice must not contain any vat */
  smallSettlement?: boolean;

  /** Is overwritten by invoice position tax rates */
  taxRate: number;

  /** A common tax text would be 'Umsatzsteuer 19%' */
  taxText: string;

  /** Tax type of the invoice.
There are four tax types:
1. default - Umsatzsteuer ausweisen
2. eu - Steuerfreie innergemeinschaftliche Lieferung (Europäische Union)
3. noteu - Steuerschuldnerschaft des Leistungsempfängers (außerhalb EU, z. B. Schweiz)
4. custom - Using custom tax set
5. ss - Not subject to VAT according to §19 1 UStG
Tax rates are heavily connected to the tax type used. */
  taxType: EnumModel_InvoiceTaxType;

  /** Tax set of the invoice. Needs to be added if you chose the tax type custom */
  taxSet?: object;

  /** Defines how many reminders have already been sent for the invoice.
    Starts with 1 (Payment reminder) and should be incremented by one every time another reminder is sent. */
  dunningLevel?: number;

  /** Payment method used for the invoice */
  paymentMethod?: ObjectReference;

  /** The date the invoice was sent to the customer */
  sendDate?: Date;

  /** Type of the invoice. For more information on the different types, check
     <a href='https:\/\/api.sevdesk.de\/#section\/Types-and-status-of-invoices'>this<\/a> section
 */
  invoiceType: EnumModel_InvoiceInvoiceType;

  /** The interval in which recurring invoices are due as ISO-8601 duration.<br>
     Necessary attribute for all recurring invoices. */
  accountIntervall?: string;

  /** Timestamp when the next invoice will be generated by this recurring invoice. */
  accountNextInvoice?: number;

  /** Currency used in the invoice. Needs to be currency code according to ISO-4217 */
  currency: string;

  /** Net sum of the invoice */
  sumNet?: number;

  /** Tax sum of the invoice */
  sumTax?: number;

  /** Gross sum of the invoice */
  sumGross?: number;

  /** Sum of all discounts in the invoice */
  sumDiscounts?: number;

  /** Net sum of the invoice in the foreign currency */
  sumNetForeignCurrency?: number;

  /** Tax sum of the invoice in the foreign currency */
  sumTaxForeignCurrency?: number;

  /** Gross sum of the invoice in the foreign currency */
  sumGrossForeignCurrency?: number;

  /** Discounts sum of the invoice in the foreign currency */
  sumDiscountsForeignCurrency?: number;

  /** Net accounting sum of the invoice. Is usually the same as sumNet */
  sumNetAccounting?: number;

  /** Tax accounting sum of the invoice. Is usually the same as sumTax */
  sumTaxAccounting?: number;

  /** Gross accounting sum of the invoice. Is usually the same as sumGross */
  sumGrossAccounting?: number;

  /** Amount which has already been paid for this invoice by the customer */
  paidAmount?: number;

  /** If true, the net amount of each position will be shown on the invoice. Otherwise gross amount */
  showNet?: boolean;

  /** Defines if and when invoice was enshrined. Enshrined invoices can not be manipulated. */
  enshrined?: Date;

  /** Type which was used to send the invoice. */
  sendType?: EnumModel_InvoiceSendType;

  /** Origin of the invoice. Could f.e. be an order */
  origin?: object;

  /** Internal note of the customer. Contains data entered into field 'Referenz\/Bestellnummer' */
  customerInternalNote?: string;

  /**  */
  mapAll: boolean;
}

export interface Model_InvoicePos {
  /** The invoice position id. <span style='color:red'>Required<\/span> if you want to update an invoice position for an existing invoice */
  id?: number;

  /** The invoice position object name */
  objectName: string;

  /**  */
  mapAll: boolean;

  /** Date of invoice position creation */
  create?: Date;

  /** Date of last invoice position update */
  update?: Date;

  /** The invoice to which the position belongs. */
  invoice?: ObjectReference;

  /** Part from your inventory which is used in the position. */
  part?: ObjectReference;

  /** Quantity of the article\/part */
  quantity: number;

  /** Price of the article\/part. Is either gross or net, depending on the sevDesk account setting. */
  price?: number;

  /** Name of the article\/part. */
  name?: string;

  /** The unit in which the positions part is measured */
  unity: ObjectReference;

  /** Client to which invoice position belongs. Will be filled automatically */
  sevClient?: object;

  /** Position number of your position. Can be used to order multiple positions. */
  positionNumber?: number;

  /** A text describing your position. */
  text?: string;

  /** An optional relative discount of the position. */
  discount?: number;

  /** An optional absolute discount of the position. */
  discountedValue?: number;

  /** An optional switch indicating whether the discount is relative (default true). */
  isPercentage?: boolean;

  /** Tax rate of the position. */
  taxRate: number;

  /** Discount sum of the position */
  sumDiscount?: number;

  /** Net accounting sum of the position */
  sumNetAccounting?: number;

  /** Tax accounting sum of the position */
  sumTaxAccounting?: number;

  /** Gross accounting sum of the position */
  sumGrossAccounting?: number;

  /** Net price of the part */
  priceNet?: number;

  /** Gross price of the part */
  priceGross?: number;

  /** Tax on the price of the part */
  priceTax?: number;
}

export interface saveInvoice {
  /**  */
  invoice: Model_Invoice;

  /**  */
  invoicePosSave?: Model_InvoicePos[];

  /**  */
  invoicePosDelete?: any | null;

  /** Filename of a previously upload file which should be attached. */
  filename?: string;

  /**  */
  discountSave?: any | null[];

  /**  */
  discountDelete?: object;
}

export interface Model_InvoicePosResponse {
  /** The invoice position id */
  id: string;

  /** The invoice position object name */
  objectName: string;

  /** Date of invoice position creation */
  create: Date;

  /** Date of last invoice position update */
  update: Date;

  /** The invoice to which the position belongs. */
  invoice?: ResponseObjectReference;

  /** Part from your inventory which is used in the position. */
  part?: ResponseObjectReference;

  /** Quantity of the article\/part */
  quantity?: number;

  /** Price of the article\/part. Is either gross or net, depending on the sevDesk account setting. */
  price?: number;

  /** Name of the article\/part. */
  name?: string;

  /** The unit in which the positions part is measured */
  unity?: ResponseObjectReference;

  /** Client to which invoice position belongs. Will be filled automatically */
  sevClient?: object;

  /** Position number of your position. Can be used to order multiple positions. */
  positionNumber?: string;

  /** A text describing your position. */
  text?: string;

  /** An optional discount of the position. */
  discount?: string;

  /** Tax rate of the position. */
  taxRate?: number;

  /** Discount sum of the position */
  sumDiscount?: number;

  /** Net accounting sum of the position */
  sumNetAccounting?: number;

  /** Tax accounting sum of the position */
  sumTaxAccounting?: number;

  /** Gross accounting sum of the position */
  sumGrossAccounting?: number;

  /** Net price of the part */
  priceNet?: number;

  /** Gross price of the part */
  priceGross?: number;

  /** Tax on the price of the part */
  priceTax?: number;
}

export interface saveInvoiceResponse {
  /**  */
  invoice: Model_InvoiceResponse;

  /**  */
  invoicePos: Model_InvoicePosResponse[];

  /** Filename of a previously upload file which should be attached. */
  filename?: string;
}

export interface Model_CreateInvoiceFromOrder {
  /** select the order for which you want to create the invoice */
  order: object;

  /** defines the type of amount */
  type?: EnumModel_CreateInvoiceFromOrderType;

  /** Amount which has already been paid for this Invoice */
  amount?: number;

  /** defines the type of the invoice
1. RE - Schlussrechnung
2. TR - Teilrechnung
3. AR - Abschlagsrechnung */
  partialType?: IModel_CreateInvoiceFromOrderPartialType;
}

export interface Model_SendInvoiceViaEMail {
  /** The recipient of the email. */
  toEmail: string;

  /** The subject of the email. */
  subject: string;

  /** The text of the email. Can contain html. */
  text: string;

  /** Should a copy of this email be sent to you? */
  copy?: boolean;

  /** Additional attachments to the mail. String of IDs of existing documents in your
   *                      sevdesk account separated by ',' */
  additionalAttachments?: string;

  /** String of mail addresses to be put as cc separated by ',' */
  ccEmail?: string;

  /** String of mail addresses to be put as bcc separated by ',' */
  bccEmail?: string;
}

export interface Model_InvoiceActivateAutoSending {
  /** communication type to use for auto sending the invoice - usually "VM" (not sure whether another would even work) */
  sendType: EnumModel_InvoiceActivateAutoSendingSendType;

  /** No clue, what this is - in my tests this value always was "P0D" */
  timeValue: string;

  /** Whether the supplied timeValue is a date */
  timeValueIsDate: boolean;

  /** Text template to use for sending the automated invoice. */
  textTemplate: ObjectReference;
}

export interface Model_Email {
  /** The email id */
  id?: number;

  /** The email object name */
  objectName?: string;

  /** Date of mail creation */
  create?: Date;

  /** Date of last mail update */
  update?: Date;

  /**  */
  object?: Model_InvoiceResponse;

  /** The sender of the email */
  from: string;

  /** The recipient of the email */
  to: string;

  /** The subject of the email */
  subject: string;

  /** The text of the email */
  text?: string;

  /** Client to which mail belongs. Will be filled automatically */
  sevClient?: object;

  /** A list of mail addresses which are in the cc */
  cc?: string;

  /** A list of mail addresses which are in the bcc */
  bcc?: string;

  /** Date the mail arrived */
  arrived?: Date;
}

export interface Model_ChangeLayout {
  /** the type to be changed */
  key: EnumModel_ChangeLayoutKey;

  /** the id\/value of the template\/letterpaper\/language\/payPal. */
  value: string;
}

export interface Model_ChangeLayoutResponse {
  /**  */
  result?: string;

  /**  */
  metadaten?: object;
}

export interface Model_OrderResponse {
  /** The order id */
  id?: string;

  /** The order object name */
  objectName?: string;

  /** Date of order creation */
  create?: Date;

  /** Date of last order update */
  update?: Date;

  /** The order number */
  orderNumber?: string;

  /** The contact used in the order */
  contact?: object;

  /** Needs to be provided as timestamp or dd.mm.yyyy */
  orderDate?: Date;

  /** Please have a look in 
    <a href='https:\/\/api.sevdesk.de\/#section\/Types-and-status-of-orders'>status of orders<\/a>
    to see what the different status codes mean */
  status?: EnumModel_OrderResponseStatus;

  /** Normally consist of prefix plus the order number */
  header?: string;

  /** Certain html tags can be used here to format your text */
  headText?: string;

  /** Certain html tags can be used here to format your text */
  footText?: string;

  /** Can be omitted as complete address is defined in address attribute */
  addressCountry?: object;

  /** Will be filled automatically by our system and can't be changed */
  createUser?: object;

  /** Client to which order belongs. Will be filled automatically */
  sevClient?: object;

  /** Delivery terms of the order */
  deliveryTerms?: string;

  /** Payment terms of the order */
  paymentTerms?: string;

  /** Object from which the order was created. For example an offer. */
  origin?: object;

  /** Version of the order.<br>
    Can be used if you have multiple drafts for the same order.<br>
    Should start with 0 */
  version?: string;

  /** Defines if the client uses the small settlement scheme.
    If yes, the order must not contain any vat */
  smallSettlement?: boolean;

  /** The user who acts as a contact person for the order */
  contactPerson?: object;

  /** Is overwritten by order position tax rates */
  taxRate?: string;

  /** Tax set of the order. Needs to be added if you chose the tax type custom */
  taxSet?: object;

  /** A common tax text would be 'Umsatzsteuer 19%' */
  taxText?: string;

  /** Tax type of the order.
There are four tax types:
1. default - Umsatzsteuer ausweisen
2. eu - Steuerfreie innergemeinschaftliche Lieferung (Europäische Union)
3. noteu - Steuerschuldnerschaft des Leistungsempfängers (außerhalb EU, z. B. Schweiz)
4. custom - Using custom tax set
5. ss - Not subject to VAT according to §19 1 UStG
Tax rates are heavily connected to the tax type used. */
  taxType?: string;

  /** Type of the order. For more information on the different types, check
    <a href='https:\/\/api.sevdesk.de\/#section\/Types-and-status-of-orders'>this<\/a>
 */
  orderType?: EnumModel_OrderResponseOrderType;

  /** The date the order was sent to the customer */
  sendDate?: Date;

  /** Complete address of the recipient including name, street, city, zip and country.<br>
     Line breaks can be used and will be displayed on the invoice pdf. */
  address?: string;

  /** Currency used in the order. Needs to be currency code according to ISO-4217 */
  currency?: string;

  /** Net sum of the order */
  sumNet?: string;

  /** Tax sum of the order */
  sumTax?: string;

  /** Gross sum of the order */
  sumGross?: string;

  /** Sum of all discounts in the order */
  sumDiscounts?: string;

  /** Net sum of the order in the foreign currency */
  sumNetForeignCurrency?: string;

  /** Tax sum of the order in the foreign currency */
  sumTaxForeignCurrency?: string;

  /** Gross sum of the order in the foreign currency */
  sumGrossForeignCurrency?: string;

  /** Discounts sum of the order in the foreign currency */
  sumDiscountsForeignCurrency?: string;

  /** Internal note of the customer. Contains data entered into field 'Referenz\/Bestellnummer' */
  customerInternalNote?: string;

  /** If true, the net amount of each position will be shown on the order. Otherwise gross amount */
  showNet?: boolean;

  /** Type which was used to send the order. IMPORTANT: Please refer to the order section of the
   *     API-Overview to understand how this attribute can be used before using it! */
  sendType?: EnumModel_OrderResponseSendType;
}

export interface Model_Order {
  /** The order id */
  id?: number;

  /** The order object name */
  objectName?: string;

  /**  */
  mapAll: boolean;

  /** Date of order creation */
  create?: Date;

  /** Date of last order update */
  update?: Date;

  /** The order number */
  orderNumber: string;

  /** The contact used in the order */
  contact: object;

  /** Needs to be provided as timestamp or dd.mm.yyyy */
  orderDate: Date;

  /** Please have a look in 
    <a href='https:\/\/api.sevdesk.de\/#section\/Types-and-status-of-orders'>status of orders<\/a>
    to see what the different status codes mean */
  status: IModel_OrderStatus;

  /** Normally consist of prefix plus the order number */
  header: string;

  /** Certain html tags can be used here to format your text */
  headText?: string;

  /** Certain html tags can be used here to format your text */
  footText?: string;

  /** Can be omitted as complete address is defined in address attribute */
  addressCountry: object;

  /** Delivery terms of the order */
  deliveryTerms?: string;

  /** Payment terms of the order */
  paymentTerms?: string;

  /** Version of the order.<br>
    Can be used if you have multiple drafts for the same order.<br>
    Should start with 0 */
  version: number;

  /** Defines if the client uses the small settlement scheme.
    If yes, the order must not contain any vat */
  smallSettlement?: boolean;

  /** The user who acts as a contact person for the order */
  contactPerson: object;

  /** Is overwritten by order position tax rates */
  taxRate: number;

  /** Tax set of the order. Needs to be added if you chose the tax type custom */
  taxSet?: object;

  /** A common tax text would be 'Umsatzsteuer 19%' */
  taxText: string;

  /** Tax type of the order.
There are four tax types:
1. default - Umsatzsteuer ausweisen
2. eu - Steuerfreie innergemeinschaftliche Lieferung (Europäische Union)
3. noteu - Steuerschuldnerschaft des Leistungsempfängers (außerhalb EU, z. B. Schweiz)
4. custom - Using custom tax set
5. ss - Not subject to VAT according to §19 1 UStG
Tax rates are heavily connected to the tax type used. */
  taxType: string;

  /** Type of the order. For more information on the different types, check
    <a href='https:\/\/api.sevdesk.de\/#section\/Types-and-status-of-orders'>this<\/a> 
 */
  orderType?: EnumModel_OrderOrderType;

  /** The date the order was sent to the customer */
  sendDate?: Date;

  /** Complete address of the recipient including name, street, city, zip and country.<br>
     Line breaks can be used and will be displayed on the invoice pdf. */
  address?: string;

  /** Currency used in the order. Needs to be currency code according to ISO-4217 */
  currency: string;

  /** Internal note of the customer. Contains data entered into field 'Referenz\/Bestellnummer' */
  customerInternalNote?: string;

  /** If true, the net amount of each position will be shown on the order. Otherwise gross amount */
  showNet?: boolean;

  /** Type which was used to send the order. IMPORTANT: Please refer to the order section of the
   *     API-Overview to understand how this attribute can be used before using it! */
  sendType?: EnumModel_OrderSendType;

  /** Object from which the order was created. For example an offer. */
  origin?: object;
}

export interface Model_OrderPos {
  /** The order position id */
  id?: number;

  /** The order position object name */
  objectName?: string;

  /** Date of order position creation */
  create?: string;

  /** Date of last order position update */
  update?: string;

  /** The order to which the position belongs. */
  order?: object;

  /** Part from your inventory which is used in the position. */
  part?: object;

  /** Quantity of the article\/part */
  quantity: number;

  /** Price of the article\/part. Is either gross or net, depending on the sevDesk account setting. */
  price?: number;

  /** Net price of the part */
  priceNet?: number;

  /** Tax on the price of the part */
  priceTax?: number;

  /** Gross price of the part */
  priceGross?: number;

  /** Name of the article\/part. */
  name?: number;

  /** The unit in which the positions part is measured */
  unity: object;

  /** Client to which order position belongs. Will be filled automatically */
  sevClient?: object;

  /** Position number of your position. Can be used to order multiple positions. */
  positionNumber?: number;

  /** A text describing your position. */
  text?: string;

  /** An optional discount of the position. */
  discount?: number;

  /** Defines if the position is optional. */
  optional?: boolean;

  /** Tax rate of the position. */
  taxRate: number;

  /** Discount sum of the position */
  sumDiscount?: number;
}

export interface saveOrder {
  /**  */
  order: Model_Order;

  /**  */
  orderPosSave?: Model_OrderPos[];

  /**  */
  orderPosDelete?: any | null;
}

export interface Model_OrderPosResponse {
  /** The order position id */
  id?: string;

  /** The order position object name */
  objectName?: string;

  /** Date of order position creation */
  create?: Date;

  /** Date of last order position update */
  update?: Date;

  /** The order to which the position belongs. */
  order?: object;

  /** Part from your inventory which is used in the position. */
  part?: object;

  /** Quantity of the article\/part */
  quantity?: string;

  /** Price of the article\/part. Is either gross or net, depending on the sevDesk account setting. */
  price?: string;

  /** Net price of the part */
  priceNet?: string;

  /** Tax on the price of the part */
  priceTax?: string;

  /** Gross price of the part */
  priceGross?: string;

  /** Name of the article\/part. */
  name?: string;

  /** The unit in which the positions part is measured */
  unity?: object;

  /** Client to which order position belongs. Will be filled automatically */
  sevClient?: object;

  /** Position number of your position. Can be used to order multiple positions. */
  positionNumber?: string;

  /** A text describing your position. */
  text?: string;

  /** An optional discount of the position. */
  discount?: string;

  /** Defines if the position is optional. */
  optional?: boolean;

  /** Tax rate of the position. */
  taxRate?: string;

  /** Discount sum of the position */
  sumDiscount?: string;
}

export interface saveOrderResponse {
  /**  */
  order?: Model_OrderResponse;

  /**  */
  orderPos?: Model_OrderPosResponse[];
}

export interface Model_OrderUpdate {
  /** The order id */
  id?: number;

  /** The order object name */
  objectName?: string;

  /** Date of order creation */
  create?: Date;

  /** Date of last order update */
  update?: Date;

  /** The order number */
  orderNumber?: string;

  /** The contact used in the order */
  contact?: object;

  /** Needs to be provided as timestamp or dd.mm.yyyy */
  orderDate?: Date;

  /** Please have a look in 
    <a href='https:\/\/api.sevdesk.de\/#section\/Types-and-status-of-orders'>status of orders<\/a>
    to see what the different status codes mean */
  status?: IModel_OrderUpdateStatus;

  /** Normally consist of prefix plus the order number */
  header?: string;

  /** Certain html tags can be used here to format your text */
  headText?: string;

  /** Certain html tags can be used here to format your text */
  footText?: string;

  /** Can be omitted as complete address is defined in address attribute */
  addressCountry?: object;

  /** Will be filled automatically by our system and can't be changed */
  createUser?: object;

  /** Client to which order belongs. Will be filled automatically */
  sevClient?: object;

  /** Delivery terms of the order */
  deliveryTerms?: string;

  /** Payment terms of the order */
  paymentTerms?: string;

  /** Object from which the order was created. For example an offer. */
  origin?: object;

  /** Version of the order.<br>
    Can be used if you have multiple drafts for the same order.<br>
    Should start with 0 */
  version?: number;

  /** Defines if the client uses the small settlement scheme.
    If yes, the order must not contain any vat */
  smallSettlement?: boolean;

  /** The user who acts as a contact person for the order */
  contactPerson?: object;

  /** Is overwritten by order position tax rates */
  taxRate?: number;

  /** Tax set of the order. Needs to be added if you chose the tax type custom */
  taxSet?: object;

  /** A common tax text would be 'Umsatzsteuer 19%' */
  taxText?: string;

  /** Tax type of the order.
There are four tax types:
1. default - Umsatzsteuer ausweisen
2. eu - Steuerfreie innergemeinschaftliche Lieferung (Europäische Union)
3. noteu - Steuerschuldnerschaft des Leistungsempfängers (außerhalb EU, z. B. Schweiz)
4. custom - Using custom tax set
5. ss - Not subject to VAT according to §19 1 UStG
Tax rates are heavily connected to the tax type used. */
  taxType?: string;

  /** Type of the order. For more information on the different types, check
    <a href='https:\/\/api.sevdesk.de\/#section\/Types-and-status-of-orders'>this<\/a>
 */
  orderType?: EnumModel_OrderUpdateOrderType;

  /** The date the order was sent to the customer */
  sendDate?: Date;

  /** Complete address of the recipient including name, street, city, zip and country.<br>
     Line breaks can be used and will be displayed on the invoice pdf. */
  address?: string;

  /** Currency used in the order. Needs to be currency code according to ISO-4217 */
  currency?: string;

  /** Net sum of the order */
  sumNet?: number;

  /** Tax sum of the order */
  sumTax?: number;

  /** Gross sum of the order */
  sumGross?: number;

  /** Sum of all discounts in the order */
  sumDiscounts?: number;

  /** Net sum of the order in the foreign currency */
  sumNetForeignCurrency?: number;

  /** Tax sum of the order in the foreign currency */
  sumTaxForeignCurrency?: number;

  /** Gross sum of the order in the foreign currency */
  sumGrossForeignCurrency?: number;

  /** Discounts sum of the order in the foreign currency */
  sumDiscountsForeignCurrency?: number;

  /** Internal note of the customer. Contains data entered into field 'Referenz\/Bestellnummer' */
  customerInternalNote?: string;

  /** If true, the net amount of each position will be shown on the order. Otherwise gross amount */
  showNet?: boolean;

  /** Type which was used to send the order. IMPORTANT: Please refer to the order section of the
   *     API-Overview to understand how this attribute can be used before using it! */
  sendType?: EnumModel_OrderUpdateSendType;
}

export interface Model_Discount {
  /** the id of the discount */
  id?: string;

  /** Model name, which is 'Discounts' */
  objectName?: string;

  /** Date of discount creation */
  create?: Date;

  /** Date of last discount update */
  update?: Date;

  /** The order used for the discount */
  object?: object;

  /** Client to which invoice belongs. Will be filled automatically */
  sevClient?: string;

  /** A text describing your position. */
  text?: string;

  /** Defines if this is a percentage or an absolute discount */
  percentage?: string;

  /** Value of the discount */
  value?: string;

  /** Defines is the Discount net or gross
0 - gross
1 - net */
  isNet?: string;
}

export interface Model_EmailOrder {
  /** The email id */
  id?: number;

  /** The email object name */
  objectName?: string;

  /** Date of mail creation */
  create?: Date;

  /** Date of last mail update */
  update?: Date;

  /**  */
  object?: Model_OrderResponse;

  /** The sender of the email */
  from: string;

  /** The recipient of the email */
  to: string;

  /** The subject of the email */
  subject: string;

  /** The text of the email */
  text?: string;

  /** Client to which mail belongs. Will be filled automatically */
  sevClient?: object;

  /** A list of mail addresses which are in the cc */
  cc?: string;

  /** A list of mail addresses which are in the bcc */
  bcc?: string;

  /** Date the mail arrived */
  arrived?: Date;
}

export interface Model_CreatePackingListFromOrder {
  /** Unique identifier of the order */
  id: number;

  /** Model name, which is 'Order' */
  objectName: string;
}

export interface Model_OrderPosUpdate {
  /** The order position id */
  id?: number;

  /** The order position object name */
  objectName?: string;

  /** Date of order position creation */
  create?: Date;

  /** Date of last order position update */
  update?: Date;

  /** The order to which the position belongs. */
  order?: object;

  /** Part from your inventory which is used in the position. */
  part?: object;

  /** Quantity of the article\/part */
  quantity?: number;

  /** Price of the article\/part. Is either gross or net, depending on the sevDesk account setting. */
  price?: number;

  /** Net price of the part */
  priceNet?: number;

  /** Tax on the price of the part */
  priceTax?: number;

  /** Gross price of the part */
  priceGross?: number;

  /** Name of the article\/part. */
  name?: number;

  /** The unit in which the positions part is measured */
  unity?: object;

  /** Client to which order position belongs. Will be filled automatically */
  sevClient?: object;

  /** Position number of your position. Can be used to order multiple positions. */
  positionNumber?: number;

  /** A text describing your position. */
  text?: string;

  /** An optional discount of the position. */
  discount?: number;

  /** Defines if the position is optional. */
  optional?: boolean;

  /** Tax rate of the position. */
  taxRate?: number;

  /** Discount sum of the position */
  sumDiscount?: number;
}

export interface Model_Voucher {
  /** The voucher id */
  id?: number;

  /** The voucher object name */
  objectName: string;

  /**  */
  mapAll: boolean;

  /** Date of voucher creation */
  create?: Date;

  /** Date of last voucher update */
  update?: Date;

  /** Client to which voucher belongs. Will be filled automatically */
  sevClient?: object;

  /** User who created the voucher. Will be filled automatically. */
  createUser?: object;

  /** Needs to be provided as timestamp or dd.mm.yyyy */
  voucherDate?: Date;

  /** The contact used in the voucher as a supplier.<br>
If you don't have a contact as a supplier, you can set this object to null. */
  supplier?: object;

  /** The supplier name.<br>
     The value you provide here will determine what supplier name is shown for the voucher in case you did not provide a supplier. */
  supplierName?: string;

  /** The description of the voucher. Essentially the voucher number. */
  description?: string;

  /** Needs to be timestamp or dd.mm.yyyy */
  payDate?: Date;

  /** Please have a look in 
    <a href='https:\/\/api.sevdesk.de\/#section\/Types-and-status-of-vouchers'>status of vouchers<\/a>
    to see what the different status codes mean */
  status: IModel_VoucherStatus;

  /** Net sum of the voucher */
  sumNet?: number;

  /** Tax sum of the voucher */
  sumTax?: number;

  /** Gross sum of the voucher */
  sumGross?: number;

  /** Net accounting sum of the voucher. Is usually the same as sumNet */
  sumNetAccounting?: number;

  /** Tax accounting sum of the voucher. Is usually the same as sumTax */
  sumTaxAccounting?: number;

  /** Gross accounting sum of the voucher. Is usually the same as sumGross */
  sumGrossAccounting?: number;

  /** Sum of all discounts in the voucher */
  sumDiscounts?: number;

  /** Discounts sum of the voucher in the foreign currency */
  sumDiscountsForeignCurrency?: number;

  /** Amount which has already been paid for this voucher by the customer */
  paidAmount?: number;

  /** Tax type of the voucher.
There are four tax types:
1. default - Umsatzsteuer ausweisen
2. eu - Steuerfreie innergemeinschaftliche Lieferung (Europäische Union)
3. noteu - Steuerschuldnerschaft des Leistungsempfängers (außerhalb EU, z. B. Schweiz)
4. custom - Using custom tax set
5. ss - Not subject to VAT according to §19 1 UStG
Tax rates are heavily connected to the tax type used. */
  taxType: string;

  /** Defines if your voucher is a credit (C) or debit (D) */
  creditDebit: EnumModel_VoucherCreditDebit;

  /** Type of the voucher. For more information on the different types, check
     <a href='https:\/\/api.sevdesk.de\/#section\/Types-and-status-of-vouchers'>this<\/a>
 */
  voucherType: EnumModel_VoucherVoucherType;

  /** specifies which currency the voucher should have. Attention: If the currency differs from the default currency stored in the account, then either the "propertyForeignCurrencyDeadline" or "propertyExchangeRate" parameter must be specified. If both parameters are specified, then the "propertyForeignCurrencyDeadline" parameter is preferred */
  currency?: string;

  /** Defines the exchange rate day and and then the exchange rate is set from sevDesk. Needs to be provided as timestamp or dd.mm.yyyy */
  propertyForeignCurrencyDeadline?: Date;

  /** Defines the exchange rate */
  propertyExchangeRate?: number;

  /** The DateInterval in which recurring vouchers are generated.<br>
     Necessary attribute for all recurring vouchers. */
  recurringInterval?: EnumModel_VoucherRecurringInterval;

  /** The date when the recurring vouchers start being generated.<br>
     Necessary attribute for all recurring vouchers. */
  recurringStartDate?: Date;

  /** The date when the next voucher should be generated.<br>
     Necessary attribute for all recurring vouchers. */
  recurringNextVoucher?: Date;

  /** The date when the last voucher was generated. */
  recurringLastVoucher?: Date;

  /** The date when the recurring vouchers end being generated.<br>
    Necessary attribute for all recurring vouchers. */
  recurringEndDate?: Date;

  /** Defines if and when voucher was enshrined. Enshrined vouchers can not be manipulated. */
  enshrined?: Date;

  /** Tax set of the voucher. Needs to be added if you chose the tax type custom */
  taxSet?: object;

  /** Payment deadline of the voucher. */
  paymentDeadline?: Date;

  /** Needs to be provided as timestamp or dd.mm.yyyy */
  deliveryDate?: Date;

  /** Needs to be provided as timestamp or dd.mm.yyyy */
  deliveryDateUntil?: Date;

  /** The document of the voucher. */
  document?: object;

  /** Cost centre for the voucher */
  costCentre?: object;
}

export interface Model_VoucherPos {
  /** The voucher position id */
  id?: number;

  /** The voucher position object name */
  objectName: string;

  /**  */
  mapAll: boolean;

  /** Date of voucher position creation */
  create?: string;

  /** Date of last voucher position update */
  update?: string;

  /** Client to which voucher position belongs. Will be filled automatically */
  sevClient?: object;

  /** The voucher to which the position belongs. */
  voucher: object;

  /** The accounting type to which the position belongs.<br>
     An accounting type is the booking account to which the position belongs.<br>
     For more information, please refer to
     <a href='https:\/\/api.sevdesk.de\/#section\/Accounting-type'>this<\/a> section. */
  accountingType: object;

  /** The accounting type to which the position belongs estimated by our voucher recognition.<br>
    An accounting type is the booking account to which the position belongs.<br>
    For more information, please refer to
    <a href='https:\/\/api.sevdesk.de\/#section\/Accounting-type'>this<\/a> section. */
  estimatedAccountingType?: object;

  /** Tax rate of the voucher position. */
  taxRate: number;

  /** Determines whether 'sumNet' or 'sumGross' is regarded.<br>
     If both are not given, 'sum' is regarded and treated as net or gross depending on 'net'. 
 All positions must be either net or gross, a mixture of the two is not possible. */
  net: boolean;

  /** Determines whether position is regarded as an asset which can be depreciated. */
  isAsset?: boolean;

  /** Net sum of the voucher position.<br>
    Only regarded if 'net' is 'true', otherwise its readOnly. */
  sumNet: number;

  /** Tax sum of the voucher position. */
  sumTax?: number;

  /** Gross sum of the voucher position.<br>
    Only regarded if 'net' is 'false', otherwise its readOnly. */
  sumGross: number;

  /** Net accounting sum. Is equal to sumNet. */
  sumNetAccounting?: number;

  /** Tax accounting sum. Is equal to sumTax. */
  sumTaxAccounting?: number;

  /** Gross accounting sum. Is equal to sumGross. */
  sumGrossAccounting?: number;

  /** Comment for the voucher position. */
  comment?: string;
}

export interface saveVoucher {
  /**  */
  voucher: Model_Voucher;

  /**  */
  voucherPosSave?: Model_VoucherPos[];

  /**  */
  voucherPosDelete?: any | null;

  /** Filename of a previously upload file which should be attached. */
  filename?: string;
}

export interface Model_VoucherResponse {
  /** The voucher id */
  id?: string;

  /** The voucher object name */
  objectName?: string;

  /**  */
  mapAll?: boolean;

  /** Date of voucher creation */
  create?: Date;

  /** Date of last voucher update */
  update?: Date;

  /** Client to which voucher belongs. Will be filled automatically */
  sevClient?: object;

  /** User who created the voucher. Will be filled automatically. */
  createUser?: object;

  /** Needs to be provided as timestamp or dd.mm.yyyy */
  voucherDate?: Date;

  /** The contact used in the voucher as a supplier.<br>
If you don't have a contact as a supplier, you can set this object to null. */
  supplier?: object;

  /** The supplier name.<br>
     The value you provide here will determine what supplier name is shown for the voucher in case you did not provide a supplier. */
  supplierName?: string;

  /** The description of the voucher. Essentially the voucher number. */
  description?: string;

  /** The document of the voucher. */
  document?: object;

  /** Needs to be timestamp or dd.mm.yyyy */
  payDate?: Date;

  /** Please have a look in 
    <a href='https:\/\/api.sevdesk.de\/#section\/Types-and-status-of-vouchers'>status of vouchers<\/a>
    to see what the different status codes mean */
  status?: EnumModel_VoucherResponseStatus;

  /** Net sum of the voucher */
  sumNet?: string;

  /** Tax sum of the voucher */
  sumTax?: string;

  /** Gross sum of the voucher */
  sumGross?: string;

  /** Net accounting sum of the voucher. Is usually the same as sumNet */
  sumNetAccounting?: string;

  /** Tax accounting sum of the voucher. Is usually the same as sumTax */
  sumTaxAccounting?: string;

  /** Gross accounting sum of the voucher. Is usually the same as sumGross */
  sumGrossAccounting?: string;

  /** Sum of all discounts in the voucher */
  sumDiscounts?: string;

  /** Discounts sum of the voucher in the foreign currency */
  sumDiscountsForeignCurrency?: string;

  /** Amount which has already been paid for this voucher by the customer */
  paidAmount?: number;

  /** Tax type of the voucher.
There are four tax types:
1. default - Umsatzsteuer ausweisen
2. eu - Steuerfreie innergemeinschaftliche Lieferung (Europäische Union)
3. noteu - Steuerschuldnerschaft des Leistungsempfängers (außerhalb EU, z. B. Schweiz)
4. custom - Using custom tax set
5. ss - Not subject to VAT according to §19 1 UStG
Tax rates are heavily connected to the tax type used. */
  taxType?: string;

  /** Defines if your voucher is a credit (C) or debit (D) */
  creditDebit?: EnumModel_VoucherResponseCreditDebit;

  /** Cost centre for the voucher */
  costCentre?: object;

  /** Type of the voucher. For more information on the different types, check
     <a href='https:\/\/api.sevdesk.de\/#section\/Types-and-status-of-vouchers'>this<\/a>
 */
  voucherType?: EnumModel_VoucherResponseVoucherType;

  /** specifies which currency the voucher should have. Attention: If the currency differs from the default currency stored in the account, then either the "propertyForeignCurrencyDeadline" or "propertyExchangeRate" parameter must be specified. If both parameters are specified, then the "propertyForeignCurrencyDeadline" parameter is preferred */
  currency?: string;

  /** Defines the exchange rate day and and then the exchange rate is set from sevDesk. Needs to be provided as timestamp or dd.mm.yyyy */
  propertyForeignCurrencyDeadline?: Date;

  /** Defines the exchange rate */
  propertyExchangeRate?: string;

  /** The DateInterval in which recurring vouchers are generated.<br>
     Necessary attribute for all recurring vouchers. */
  recurringInterval?: EnumModel_VoucherResponseRecurringInterval;

  /** The date when the recurring vouchers start being generated.<br>
     Necessary attribute for all recurring vouchers. */
  recurringStartDate?: Date;

  /** The date when the next voucher should be generated.<br>
     Necessary attribute for all recurring vouchers. */
  recurringNextVoucher?: Date;

  /** The date when the last voucher was generated. */
  recurringLastVoucher?: Date;

  /** The date when the recurring vouchers end being generated.<br>
    Necessary attribute for all recurring vouchers. */
  recurringEndDate?: Date;

  /** Defines if and when voucher was enshrined. Enshrined vouchers can not be manipulated. */
  enshrined?: Date;

  /** Tax set of the voucher. Needs to be added if you chose the tax type custom */
  taxSet?: object;

  /** Payment deadline of the voucher. */
  paymentDeadline?: Date;

  /** Needs to be provided as timestamp or dd.mm.yyyy */
  deliveryDate?: Date;

  /** Needs to be provided as timestamp or dd.mm.yyyy */
  deliveryDateUntil?: Date;
}

export interface Model_VoucherPosResponse {
  /** The voucher position id */
  id?: string;

  /** The voucher position object name */
  objectName?: string;

  /** Date of voucher position creation */
  create?: string;

  /** Date of last voucher position update */
  update?: string;

  /** Client to which voucher position belongs. Will be filled automatically */
  sevClient?: object;

  /** The voucher to which the position belongs. */
  voucher: object;

  /** The accounting type to which the position belongs.<br>
     An accounting type is the booking account to which the position belongs.<br>
     For more information, please refer to
     <a href='https:\/\/api.sevdesk.de\/#section\/Accounting-type'>this<\/a> section. */
  accountingType: object;

  /** The accounting type to which the position belongs estimated by our voucher recognition.<br>
    An accounting type is the booking account to which the position belongs.<br>
    For more information, please refer to
    <a href='https:\/\/api.sevdesk.de\/#section\/Accounting-type'>this<\/a> section. */
  estimatedAccountingType?: object;

  /** Tax rate of the voucher position. */
  taxRate: string;

  /** Determines whether 'sumNet' or 'sumGross' is regarded.<br>
     If both are not given, 'sum' is regarded and treated as net or gross depending on 'net'.
 All positions must be either net or gross, a mixture of the two is not possible. */
  net: boolean;

  /** Determines whether position is regarded as an asset which can be depreciated. */
  isAsset?: boolean;

  /** Net sum of the voucher position.<br>
    Only regarded if 'net' is 'true', otherwise its readOnly. */
  sumNet: string;

  /** Tax sum of the voucher position. */
  sumTax?: string;

  /** Gross sum of the voucher position.<br>
    Only regarded if 'net' is 'false', otherwise its readOnly. */
  sumGross: string;

  /** Net accounting sum. Is equal to sumNet. */
  sumNetAccounting?: string;

  /** Tax accounting sum. Is equal to sumTax. */
  sumTaxAccounting?: string;

  /** Gross accounting sum. Is equal to sumGross. */
  sumGrossAccounting?: string;

  /** Comment for the voucher position. */
  comment?: string;
}

export interface saveVoucherResponse {
  /**  */
  voucher?: Model_VoucherResponse;

  /**  */
  voucherPos?: Model_VoucherPosResponse[];

  /** Filename of a previously upload file which should be attached. */
  filename?: string;
}

export interface validationError {
  /**  */
  error?: object;
}

export interface Model_VoucherUpdate {
  /** Needs to be provided as timestamp or dd.mm.yyyy */
  voucherDate?: Date;

  /** The contact used in the voucher as a supplier.<br>
If you don't have a contact as a supplier, you can set this object to null. */
  supplier?: object;

  /** The supplier name.<br>
     The value you provide here will determine what supplier name is shown for the voucher in case you did not provide a supplier. */
  supplierName?: string;

  /** The description of the voucher. Essentially the voucher number. */
  description?: string;

  /** Needs to be timestamp or dd.mm.yyyy */
  payDate?: Date;

  /** Please have a look in 
    <a href='https:\/\/api.sevdesk.de\/#section\/Types-and-status-of-vouchers'>status of vouchers<\/a>
    to see what the different status codes mean */
  status?: IModel_VoucherUpdateStatus;

  /** Amount which has already been paid for this voucher by the customer */
  paidAmount?: number;

  /** Tax type of the voucher.
There are four tax types:
1. default - Umsatzsteuer ausweisen
2. eu - Steuerfreie innergemeinschaftliche Lieferung (Europäische Union)
3. noteu - Steuerschuldnerschaft des Leistungsempfängers (außerhalb EU, z. B. Schweiz)
4. custom - Using custom tax set
5. ss - Not subject to VAT according to §19 1 UStG
Tax rates are heavily connected to the tax type used. */
  taxType?: string;

  /** Defines if your voucher is a credit (C) or debit (D) */
  creditDebit?: EnumModel_VoucherUpdateCreditDebit;

  /** Type of the voucher. For more information on the different types, check
     <a href='https:\/\/api.sevdesk.de\/#section\/Types-and-status-of-vouchers'>this<\/a>
 */
  voucherType?: EnumModel_VoucherUpdateVoucherType;

  /** specifies which currency the voucher should have. Attention: If the currency differs from the default currency stored in the account, then either the "propertyForeignCurrencyDeadline" or "propertyExchangeRate" parameter must be specified. If both parameters are specified, then the "propertyForeignCurrencyDeadline" parameter is preferred */
  currency?: string;

  /** Defines the exchange rate day and and then the exchange rate is set from sevDesk. Needs to be provided as timestamp or dd.mm.yyyy */
  propertyForeignCurrencyDeadline?: Date;

  /** Defines the exchange rate */
  propertyExchangeRate?: number;

  /** Tax set of the voucher. Needs to be added if you chose the tax type custom */
  taxSet?: object;

  /** Payment deadline of the voucher. */
  paymentDeadline?: Date;

  /** Needs to be provided as timestamp or dd.mm.yyyy */
  deliveryDate?: Date;

  /** Needs to be provided as timestamp or dd.mm.yyyy */
  deliveryDateUntil?: Date;

  /** The document of the voucher. */
  document?: object;

  /** Cost centre for the voucher */
  costCentre?: object;
}

export interface Model_TagResponse {
  /** Id of the tag */
  id?: string;

  /** Internal object name which is 'Tag'. */
  objectName?: string;

  /**  */
  additionalInformation?: string;

  /** Date of tag creation */
  create?: Date;

  /** name of the tag */
  name?: string;

  /** Client to which invoice belongs. Will be filled automatically */
  sevClient?: object;
}

export interface Model_TagCreateResponse {
  /** Id of the tag */
  id?: string;

  /** Internal object name which is 'TagRelation'. */
  objectName?: string;

  /**  */
  additionalInformation?: string;

  /** Date of tag creation */
  create?: Date;

  /** The tag information */
  tag?: object;

  /**  */
  object?: object;

  /** Client to which invoice belongs. Will be filled automatically */
  sevClient?: object;
}
export enum EnumModel_CheckAccountResponseType {
  "online" = "online",
  "offline" = "offline",
}
export enum EnumModel_CheckAccountResponseImportType {
  "CSV" = "CSV",
  "MT940" = "MT940",
  "KEY_null" = "null",
}
export enum EnumModel_CheckAccountResponseStatus {
  "KEY_0" = "0",
  "KEY_100" = "100",
}
export enum EnumModel_CheckAccountType {
  "online" = "online",
  "offline" = "offline",
}
export enum EnumModel_CheckAccountImportType {
  "CSV" = "CSV",
  "MT940" = "MT940",
  "KEY_null" = "null",
}
type IModel_CheckAccountDefaultAccount = 0 | 1;
type IModel_CheckAccountStatus = 0 | 100;
export enum EnumModel_CheckAccountUpdateType {
  "online" = "online",
  "offline" = "offline",
}
export enum EnumModel_CheckAccountUpdateImportType {
  "CSV" = "CSV",
  "MT940" = "MT940",
  "KEY_null" = "null",
}
type IModel_CheckAccountUpdateDefaultAccount = 0 | 1;
type IModel_CheckAccountUpdateStatus = 0 | 100;
export enum EnumModel_CheckAccountTransactionResponseStatus {
  "KEY_100" = "100",
  "KEY_200" = "200",
  "KEY_300" = "300",
  "KEY_400" = "400",
}
type IModel_CheckAccountTransactionStatus = 100 | 200 | 300 | 400;
type IModel_CheckAccountTransactionUpdateStatus = 100 | 200 | 300 | 400;
export enum EnumModel_ContactResponseTaxType {
  "default" = "default",
  "eu" = "eu",
  "noteu" = "noteu",
  "custom" = "custom",
  "ss" = "ss",
}
export enum EnumModel_ContactStatus {
  "LEAD"=100,
  "PENDING"=500,
  "ACTIVE"=1000
}
export enum EnumModel_ContactCategory {
  "SUPPLIER"={
    id: 2,
    objectName: "Category"
  },
  "CUSTOMER"={
    id: 3,
    objectName: "Category"
  },
  "PARTNER"={
    id: 4,
    objectName: "Category"
  },
  "PROSPECT_CUSTOMER"={
    id: 28,
    objectName: "Category"
  }
}
export enum EnumModel_ContactTaxType {
  "default" = "default",
  "eu" = "eu",
  "noteu" = "noteu",
  "custom" = "custom",
  "ss" = "ss",
}
export enum EnumModel_ContactUpdateTaxType {
  "default" = "default",
  "eu" = "eu",
  "noteu" = "noteu",
  "custom" = "custom",
  "ss" = "ss",
}
export enum EnumModel_CommunicationWayResponseType {
  "EMAIL" = "EMAIL",
  "PHONE" = "PHONE",
  "WEB" = "WEB",
  "MOBILE" = "MOBILE",
}
export enum EnumModel_CommunicationWayType {
  "EMAIL" = "EMAIL",
  "PHONE" = "PHONE",
  "WEB" = "WEB",
  "MOBILE" = "MOBILE",
}
export enum EnumModel_CommunicationWayUpdateType {
  "EMAIL" = "EMAIL",
  "PHONE" = "PHONE",
  "WEB" = "WEB",
  "MOBILE" = "MOBILE",
}
export type CombinedContactCustomFieldSettingTypes =
  Model_ContactCustomFieldSettingResponse;
export enum EnumModel_creditNoteResponseStatus {
  "KEY_100" = "100",
  "KEY_200" = "200",
  "KEY_1000" = "1000",
}
export enum EnumModel_creditNoteResponseSendType {
  "VPR" = "VPR",
  "VPDF" = "VPDF",
  "VM" = "VM",
  "VP" = "VP",
}
export enum EnumModel_creditNoteStatus {
  "KEY_100" = "100",
  "KEY_200" = "200",
  "KEY_300" = "300",
  "KEY_500" = "500",
  "KEY_750" = "750",
  "KEY_1000" = "1000",
}
export enum EnumModel_creditNoteBookingCategory {
  "PROVISION" = "PROVISION",
  "ROYALTY_ASSIGNED" = "ROYALTY_ASSIGNED",
  "ROYALTY_UNASSIGNED" = "ROYALTY_UNASSIGNED",
  "UNDERACHIEVEMENT" = "UNDERACHIEVEMENT",
  "ACCOUNTING_TYPE" = "ACCOUNTING_TYPE",
}
export enum EnumModel_creditNoteSendType {
  "VPR" = "VPR",
  "VPDF" = "VPDF",
  "VM" = "VM",
  "VP" = "VP",
}
export enum EnumModel_creditNoteUpdateStatus {
  "KEY_100" = "100",
  "KEY_200" = "200",
  "KEY_1000" = "1000",
}
export enum EnumModel_creditNoteUpdateSendType {
  "VPR" = "VPR",
  "VPDF" = "VPDF",
  "VM" = "VM",
  "VP" = "VP",
}
type IModel_PartStatus = 50 | 100;
type IModel_PartUpdateStatus = 50 | 100;
export enum EnumModel_InvoiceResponseStatus {
  "KEY_50" = "50",
  "KEY_100" = "100",
  "KEY_200" = "200",
  "KEY_1000" = "1000",
}
export enum EnumModel_InvoiceResponseTaxType {
  "default" = "default",
  "eu" = "eu",
  "noteu" = "noteu",
  "custom" = "custom",
}
export enum EnumModel_InvoiceResponseInvoiceType {
  "RE" = "RE",
  "WKR" = "WKR",
  "SR" = "SR",
  "MA" = "MA",
  "TR" = "TR",
  "ER" = "ER",
}
export enum EnumModel_InvoiceResponseSendType {
  "VPR" = "VPR",
  "VPDF" = "VPDF",
  "VM" = "VM",
  "VP" = "VP",
}
export enum EnumModel_InvoiceStatus {
  "KEY_50" = "50",
  "KEY_100" = "100",
  "KEY_200" = "200",
  "KEY_1000" = "1000",
}
export enum EnumModel_InvoiceTaxType {
  "default" = "default",
  "eu" = "eu",
  "noteu" = "noteu",
  "custom" = "custom",
}
export enum EnumModel_InvoiceInvoiceType {
  "RE" = "RE",
  "WKR" = "WKR",
  "SR" = "SR",
  "MA" = "MA",
  "TR" = "TR",
  "ER" = "ER",
}
export enum EnumModel_InvoiceSendType {
  "VPR" = "VPR",
  "VPDF" = "VPDF",
  "VM" = "VM",
  "VP" = "VP",
}
export enum EnumModel_CreateInvoiceFromOrderType {
  "percentage" = "percentage",
  "net" = "net",
  "gross" = "gross",
}
type IModel_CreateInvoiceFromOrderPartialType = "RE" | "TR" | "AR";
export enum EnumModel_InvoiceActivateAutoSendingSendType {
  "VPR" = "VPR", // printed
  "VPDF" = "VPDF", // downloaded
  "VM" = "VM", // mailed
  "VP" = "VP" // postal
}
export enum EnumModel_ChangeLayoutKey {
  "language" = "language",
  "template" = "template",
  "letterpaper" = "letterpaper",
  "payPal" = "payPal",
}
export enum EnumModel_OrderResponseStatus {
  "KEY_100" = "100",
  "KEY_200" = "200",
  "KEY_300" = "300",
  "KEY_500" = "500",
  "KEY_750" = "750",
  "KEY_1000" = "1000",
}
export enum EnumModel_OrderResponseOrderType {
  "AN" = "AN",
  "AB" = "AB",
  "LI" = "LI",
}
export enum EnumModel_OrderResponseSendType {
  "VPR" = "VPR",
  "VPDF" = "VPDF",
  "VM" = "VM",
  "VP" = "VP",
}
type IModel_OrderStatus = 100 | 200 | 300 | 500 | 750 | 1000;
export enum EnumModel_OrderOrderType {
  "AN" = "AN",
  "AB" = "AB",
  "LI" = "LI",
}
export enum EnumModel_OrderSendType {
  "VPR" = "VPR",
  "VPDF" = "VPDF",
  "VM" = "VM",
  "VP" = "VP",
}
type IModel_OrderUpdateStatus = 100 | 200 | 300 | 500 | 750 | 1000;
export enum EnumModel_OrderUpdateOrderType {
  "AN" = "AN",
  "AB" = "AB",
  "LI" = "LI",
}
export enum EnumModel_OrderUpdateSendType {
  "VPR" = "VPR",
  "VPDF" = "VPDF",
  "VM" = "VM",
  "VP" = "VP",
}
type IModel_VoucherStatus = 50 | 100 | 1000;
export enum EnumModel_VoucherCreditDebit {
  "C" = "C",
  "D" = "D",
}
export enum EnumModel_VoucherVoucherType {
  "VOU" = "VOU",
  "RV" = "RV",
}
export enum EnumModel_VoucherRecurringInterval {
  "P0Y0M1W" = "P0Y0M1W",
  "P0Y0M2W" = "P0Y0M2W",
  "P0Y1M0W" = "P0Y1M0W",
  "P0Y3M0W" = "P0Y3M0W",
  "P0Y6M0W" = "P0Y6M0W",
  "P1Y0M0W" = "P1Y0M0W",
  "P2Y0M0W" = "P2Y0M0W",
  "P3Y0M0W" = "P3Y0M0W",
  "P4Y0M0W" = "P4Y0M0W",
  "P5Y0M0W" = "P5Y0M0W",
}
export enum EnumModel_VoucherResponseStatus {
  "KEY_50" = "50",
  "KEY_100" = "100",
  "KEY_1000" = "1000",
}
export enum EnumModel_VoucherResponseCreditDebit {
  "C" = "C",
  "D" = "D",
}
export enum EnumModel_VoucherResponseVoucherType {
  "VOU" = "VOU",
  "RV" = "RV",
}
export enum EnumModel_VoucherResponseRecurringInterval {
  "P0Y0M1W" = "P0Y0M1W",
  "P0Y0M2W" = "P0Y0M2W",
  "P0Y1M0W" = "P0Y1M0W",
  "P0Y3M0W" = "P0Y3M0W",
  "P0Y6M0W" = "P0Y6M0W",
  "P1Y0M0W" = "P1Y0M0W",
  "P2Y0M0W" = "P2Y0M0W",
  "P3Y0M0W" = "P3Y0M0W",
  "P4Y0M0W" = "P4Y0M0W",
  "P5Y0M0W" = "P5Y0M0W",
}
type IModel_VoucherUpdateStatus = 50 | 100 | 1000;
export enum EnumModel_VoucherUpdateCreditDebit {
  "C" = "C",
  "D" = "D",
}
export enum EnumModel_VoucherUpdateVoucherType {
  "VOU" = "VOU",
  "RV" = "RV",
}
